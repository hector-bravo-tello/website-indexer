
// Filename: app/api/auth/[...nextauth]/route.ts
// app/api/auth/[...nextauth]/route.ts

import NextAuth from 'next-auth';
import { authOptions } from '@/lib/authOptions';

// Create handler from NextAuth using authOptions
const handler = NextAuth(authOptions);

// Export HTTP handlers for Next.js API route compliance
export { handler as GET, handler as POST };


// Filename: app/api/sae/route.ts
// File: app/api/sae/route.ts

import { NextResponse } from 'next/server';
import { withErrorHandling } from '@/utils/apiUtils';
import CONFIG from '@/config';

// returns the service account email used for the Google Search Console API
export const GET = withErrorHandling(async () => {
  const email = CONFIG.google.clientEmail;

  if (!email) {
    return NextResponse.json({ error: 'Service account email not configured' }, { status: 500 });
  }

  return NextResponse.json({ email });
});

// Filename: app/api/websites/[websiteId]/indexing-stats/route.ts
// Filename: /app/api/websites/[websiteId]/indexing-stats/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from '@/lib/authOptions';
import { getIndexingStatsByWebsiteId } from '@/models';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError } from '@/utils/errors';

export const GET = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
      throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.nextUrl.pathname.split('/')[3]);

  if (isNaN(websiteId)) {
    throw new NotFoundError('Invalid website ID');
  }

  const indexingStats = await getIndexingStatsByWebsiteId(websiteId);
  return NextResponse.json({ indexingStats });
});


// Filename: app/api/websites/[websiteId]/metrics/route.ts
// File: app/api/websites/[websiteId]/metrics/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from '@/lib/authOptions';
import { getWebsiteById } from '@/models';
import { getPageImpressionsAndClicks } from '@/lib/googleSearchConsole';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError, ValidationError } from '@/utils/errors';

export const POST = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.nextUrl.pathname.split('/')[3]);
  
  if (isNaN(websiteId)) {
    throw new ValidationError('Invalid website ID');
  }

  const { website } = await getWebsiteById(websiteId);

  if (!website || website.user_id !== parseInt(session.user.id)) {
    throw new NotFoundError('Website not found');
  }

  const body = await request.json();
  const { urls } = body;

  if (!Array.isArray(urls)) {
    throw new ValidationError('Invalid request body. Expected "urls" array.');
  }

  const metricsData = await getPageImpressionsAndClicks(websiteId, urls);
  return NextResponse.json({ 
    data: metricsData, 
    message: Object.keys(metricsData).length === 0 ? 'No data returned from Google Search Console' : 'Metrics retrieved successfully' 
  });
});

// Filename: app/api/websites/[websiteId]/pages/[pageId]/submit-for-indexing/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from '@/lib/authOptions';
import { getWebsiteById, getPageById, updatePageData } from '@/models';
import { submitUrlForIndexing } from '@/lib/googleSearchConsole';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError, ValidationError } from '@/utils/errors';

export const POST = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.nextUrl.pathname.split('/')[3]);
  const pageId = parseInt(request.nextUrl.pathname.split('/')[5]);

  if (isNaN(websiteId) || isNaN(pageId)) {
    throw new ValidationError('Invalid website ID or page ID');
  }

  const { website } = await getWebsiteById(websiteId);
  const { page } = await getPageById(pageId);

  if (!website || !page || website.id !== page.website_id) {
    throw new NotFoundError('Website or page not found');
  }

  if (website.user_id !== parseInt(session.user.id)) {
    throw new AuthenticationError('You do not have permission to submit this page');
  }

  // Check if 24 hours have passed since the last submission
  const lastSubmissionDate = new Date(page.last_indexed_date as Date);
  const currentDate = new Date();
  const hoursSinceLastSubmission = (currentDate.getTime() - lastSubmissionDate.getTime()) / (1000 * 60 * 60);

  if (hoursSinceLastSubmission < 24) {
    throw new ValidationError('You can only submit a page for indexing once every 24 hours');
  }
 
  // Submit the URL for indexing
  await submitUrlForIndexing(website.domain, page.url);

  // Update the page's last indexed date
  await updatePageData(websiteId, page.url, 'Submitted', new Date());

  return NextResponse.json({ message: 'Page submitted for indexing successfully' });
});

// Filename: app/api/websites/[websiteId]/pages/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from '@/lib/authOptions';
import { getPagesByWebsiteId, getWebsiteById } from '@/models';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError } from '@/utils/errors';

export const GET = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.nextUrl.pathname.split('/')[3]);
  const searchParams = request.nextUrl.searchParams;
  const all = searchParams.get('all') === 'true';
  const page = parseInt(searchParams.get('page') || '0');
  const pageSize = parseInt(searchParams.get('pageSize') || '25');
  const orderBy = searchParams.get('orderBy') || 'url';
  const order = searchParams.get('order') || 'asc';

  if (isNaN(websiteId)) {
    throw new NotFoundError('Invalid website ID');
  }

  const { website } = await getWebsiteById(websiteId);

  if (!website || website.user_id !== parseInt(session.user.id)) {
    throw new NotFoundError('Website not found');
  }

  const { pages, totalCount } = await getPagesByWebsiteId(websiteId, all, page, pageSize, orderBy, order as 'asc' | 'desc');

  return NextResponse.json({ pages, totalCount });
});

// Filename: app/api/websites/[websiteId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from '@/lib/authOptions';
import { getWebsiteById } from '@/models';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError } from '@/utils/errors';

export const GET = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.nextUrl.pathname.split('/')[3]);

  if (isNaN(websiteId)) {
    throw new NotFoundError('Invalid website ID');
  }

  const { website } = await getWebsiteById(websiteId);

  if (!website || website.user_id !== parseInt(session.user.id)) {
    throw new NotFoundError('Website not found');
  }

  return NextResponse.json(website);
});

// Filename: app/api/websites/[websiteId]/toggle/route.ts
// File: app/api/websites/[websiteId]/toggle-indexing/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from '@/lib/authOptions';
import { getWebsiteById, updateWebsite } from '@/models';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError, ValidationError } from '@/utils/errors';
import jobQueue from '@/lib/jobQueue';

export const POST = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.url.split('/').slice(-2)[0]);

  if (isNaN(websiteId)) {
    throw new ValidationError('Invalid website ID');
  }

  const { website } = await getWebsiteById(websiteId);
  if (!website) {
    throw new NotFoundError('Website not found');
  }

  if (website.user_id !== parseInt(session.user.id)) {
    throw new AuthenticationError('You do not have permission to modify this website');
  }

  const body = await request.json();
  const { enabled, auto_indexing_enabled } = body;

  if (typeof enabled !== 'boolean' && typeof auto_indexing_enabled !== 'boolean') {
    throw new ValidationError('Invalid request body. Expected "enabled" or "auto_indexing_enabled" boolean field.');
  }

  const { website: updatedWebsite } = await updateWebsite(websiteId, { enabled: enabled, auto_indexing_enabled: auto_indexing_enabled });

  let message: string = '';
  let shouldRunJob: boolean = false;

  if (enabled) {
    message = auto_indexing_enabled ? 'Website enabled. Auto-indexing enabled.' : 'Website enabled. Auto-indexing disabled.';
    shouldRunJob = !website.last_robots_scan || new Date(website.last_robots_scan).getTime() < Date.now() - 24 * 60 * 60 * 1000;

    if (shouldRunJob) {
      try {
        await jobQueue.addJob(websiteId, 'ui');
        message = 'Fetching data from Google Search Console...';

      } catch (error) {
        console.error(`Failed to fetch data for website ${websiteId}:`, error);
      }
    }
  } else {  
    message = 'Website disabled.';
  }

  return NextResponse.json({ 
    website: updatedWebsite, 
    message,
    initialScanTime: website.last_robots_scan?.toISOString()
  });
});

export const GET = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.url.split('/').slice(-2)[0]);
  const initialScanTime = request.nextUrl.searchParams.get('initialScanTime');

  if (isNaN(websiteId) || !initialScanTime) {
    throw new ValidationError('Invalid website ID or initial scan time');
  }

  const { website } = await getWebsiteById(websiteId);
  
  if (!website || website.user_id !== parseInt(session.user.id)) {
    throw new NotFoundError('Website not found');
  }

  const isCompleted = website.last_robots_scan && new Date(website.last_robots_scan) > new Date(initialScanTime);

  return NextResponse.json({ 
    isCompleted,
    lastScanTime: website.last_robots_scan?.toISOString()
  });
});

// Filename: app/api/websites/[websiteId]/verify-ownership/route.ts
// File: app/api/websites/[websiteId]/verify-ownership/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from '@/lib/authOptions';
import { getWebsiteById } from '@/models';
import { verifyWebsiteOwnership } from '@/lib/googleSearchConsole';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError, ValidationError } from '@/utils/errors';

export const GET = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.url.split('/').slice(-2)[0]);

  if (isNaN(websiteId)) {
    throw new ValidationError('Invalid website ID');
  }

  const { website } = await getWebsiteById(websiteId);
  if (!website) {
    throw new NotFoundError('Website not found');
  }

  if (website.user_id !== parseInt(session.user.id)) {
    throw new AuthenticationError('You do not have permission to verify this website');
  }

  const isOwner = await verifyWebsiteOwnership(website.domain);

  return NextResponse.json({ 
    is_owner: isOwner,
    message: isOwner ? 'Ownership verified successfully.' : 'No Ownership permissions.'
  });
});

// Filename: app/api/websites/daily-indexing/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getWebsitesForIndexing } from '@/models';
import { processWebsiteForScheduledJob } from '@/lib/scheduledSitemapProcessor';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthorizationError } from '@/utils/errors';
import CONFIG from '@/config';

export const POST = withErrorHandling(async (request: NextRequest) => {
  // Check for a secret token to ensure this route is only called by authorized systems
  if (request.headers.get('x-api-key') !== CONFIG.apiKeys.dailyIndexing) {
    throw new AuthorizationError('Invalid API key');
  }

  console.log('Starting daily indexing job');
  
  const { websites } = await getWebsitesForIndexing();

  console.log(`Found ${websites.length} websites to process`);

  for (const website of websites) {
    try {
      console.log(`Processing website: ${website.domain}`);
      await processWebsiteForScheduledJob(website);
      console.log(`Finished processing website: ${website.domain}`);

    } catch (error) {
      console.error(`Error processing website ${website.domain}:`, error);
    }
  }     

  console.log('Daily indexing job completed');

  return NextResponse.json({ message: 'Daily indexing job completed successfully' });
});

// Filename: app/api/websites/refresh/route.ts
// File: app/api/websites/refresh/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from '@/lib/authOptions';
import { fetchAndStoreWebsites } from '@/lib/googleSearchConsole';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError } from '@/utils/errors';

export const POST = withErrorHandling(async () => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user?.id) {
    throw new AuthenticationError('Unauthorized');
  }

  const userId = parseInt(session.user.id);
  await fetchAndStoreWebsites(userId);

  return NextResponse.json({ message: 'Websites refreshed successfully' });
});

// Filename: app/api/websites/route.ts
import { NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from '@/lib/authOptions';
import { getWebsitesByUserId } from '@/models';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError } from '@/utils/errors';
import { verifyWebsiteOwnership } from '@/lib/googleSearchConsole';
import { Website } from '@/types';

export const GET = withErrorHandling(async () => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const userId = parseInt(session.user.id);
  const { websites } = await getWebsitesByUserId(userId);

  if (!websites || websites.length === 0) {
    return NextResponse.json([]);
  }

  const websitesWithOwnership: Website[] = await Promise.all(
    websites.map(async (website) => {
      try {
        const isOwner = await verifyWebsiteOwnership(website.domain);
        return { ...website, is_owner: isOwner };

      } catch (error) {
        console.error(`Error verifying ownership for ${website.domain}:`, error);
        return { ...website, is_owner: null };
      }
    })
  );

  return NextResponse.json(websitesWithOwnership);
});

// Filename: app/auth/signin/page.tsx
'use client';

import { Box, Typography, Button, useMediaQuery, Theme } from '@mui/material';
import Image from "next/image";
import { signIn } from 'next-auth/react';
import { Google as GoogleIcon } from '@mui/icons-material';

export default function LoginPage() {
  const isMobile = useMediaQuery((theme: Theme) => theme.breakpoints.down('sm'));

  return (
    <Box sx={{ 
      display: 'flex', 
      flexDirection: isMobile ? 'column' : 'row',
      height: '100vh',
    }}>
      {/* Left side with image */}
      <Box sx={{ 
        flex: isMobile ? 'none' : 1, 
        position: 'relative',
        height: isMobile ? '30vh' : '100vh',
      }}>
        <Image
          src="/images/background.webp"
          alt="Website Indexer"
          priority
          layout="fill"
          objectFit="cover"
        />
      </Box>

      {/* Right side with login form */}
      <Box sx={{ 
        flex: isMobile ? 'none' : 1, 
        display: 'flex', 
        flexDirection: 'column', 
        justifyContent: 'center', 
        alignItems: 'center', 
        p: 4,
        height: isMobile ? '70vh' : '100vh',
      }}>
        <Typography variant="h4" component="h1" gutterBottom align="center">
          Website Indexer
        </Typography>
        <Typography variant="h6" component="h2" gutterBottom align="center">
          Inicia sesión o regístrate
        </Typography>

        <Box sx={{ mt: 4, width: '100%', maxWidth: 300 }}>
          <Button
            fullWidth
            variant="contained"
            color="primary"
            startIcon={<GoogleIcon />}
            onClick={() => signIn('google', { callbackUrl: '/dashboard' })}
            sx={{ mb: 2 }}
          >
            Continúa con Google
          </Button>

          <Typography variant="body2" align="center" sx={{ mt: 2 }}>
            Al continuar, aceptas nuestros{' '}
            <a href="/terms" style={{ color: 'blue' }}>Términos de uso</a> y nuestra{' '}
            <a href="/privacy" style={{ color: 'blue' }}>Política de privacidad</a>
          </Typography>
        </Box>
      </Box>
    </Box>
  );
}

// Filename: app/dashboard/page.tsx
'use client';

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import Link from 'next/link';
import { 
  Container, 
  Typography, 
  Box, 
  CircularProgress, 
  Snackbar,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow, 
  Paper, 
  TablePagination, 
  TableSortLabel,
  Button,
  Switch,
  IconButton,
  Tooltip,
  Chip,
  useTheme,
  useMediaQuery,
  Grid,
  Card,
  CardContent
} from '@mui/material';
import MuiAlert, { AlertProps } from '@mui/material/Alert';
import { Refresh as RefreshIcon, Info as InfoIcon } from '@mui/icons-material';
import { WithAuth } from '@/components/WithAuth';
import { PermissionsModal } from '@/components/PermissionsModal';
import { Website } from '@/types';
import { useError } from '@/lib/useError';

const Dashboard: React.FC = () => {
  const [modalOpen, setModalOpen] = useState(false);
  const [websites, setWebsites] = useState<Website[] | null>(null);
  const [loading, setLoading] = useState(true);
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [orderBy, setOrderBy] = useState<keyof Website>('domain');
  const [order, setOrder] = useState<'asc' | 'desc'>('asc');
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' }>({
    open: false,
    message: '',
    severity: 'success',
  });
  const [serviceAccountEmail, setServiceAccountEmail] = useState('');
  const setError = useError();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const Alert = React.forwardRef<HTMLDivElement, AlertProps>(function Alert(
    props,
    ref,
  ) {
    return <MuiAlert elevation={6} ref={ref} variant="filled" {...props} />;
  });

  const fetchServiceAccountEmail = useCallback(async () => {
    try {
      const response = await fetch('/api/sae');
      if (!response.ok) {
        throw new Error('Failed to fetch service account email');
      }
      const data = await response.json();
      setServiceAccountEmail(data.email);
    } catch (error) {
      console.error('Error fetching service account email:', error);
      setError('Failed to load service account email. Please try again later.');
    }
  }, [setError]);

  const fetchWebsites = useCallback(async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/websites');
      if (!response.ok) {
        throw new Error('Failed to fetch websites');
      }
      const data = await response.json();
      setWebsites(data);
    } catch (error) {
      console.error('Error fetching websites:', error);
      setError('Failed to load websites. Please try again later.');
    } finally {
      setLoading(false);
    }
  }, [setError]);

  useEffect(() => {
    fetchWebsites();
    fetchServiceAccountEmail();
  }, [fetchWebsites, fetchServiceAccountEmail]);

  const handleToggleEnabled = async (websiteId: number, currentStatus: boolean) => {
    try {
      const response = await fetch(`/api/websites/${websiteId}/toggle`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ enabled: !currentStatus }),
      });
      if (!response.ok) {
        throw new Error('Failed to toggle indexing');
      }
      const data = await response.json();
      setWebsites(prevWebsites => 
        prevWebsites?.map(website => 
          website.id === websiteId ? { ...website, enabled: !currentStatus } : website
        ) || null
      );
      setSnackbar({
        open: true,
        message: data.message,
        severity: 'success',
      });
    } catch (error) {
      console.error('Error toggling indexing:', error);
      setError('Failed to update indexing status. Please try again later.');
      setSnackbar({
        open: true,
        message: 'Failed to update indexing status',
        severity: 'error',
      });
    }
  };

  const handleToggleAutoIndexing = async (websiteId: number, currentStatus: boolean) => {
    try {
      const response = await fetch(`/api/websites/${websiteId}/toggle`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ auto_indexing_enabled: !currentStatus }),
      });
      if (!response.ok) {
        throw new Error('Failed to toggle auto-indexing');
      }
      const data = await response.json();
      setWebsites(prevWebsites => 
        prevWebsites?.map(website => 
          website.id === websiteId ? { ...website, auto_indexing_enabled: !currentStatus } : website
        ) || null
      );
      setSnackbar({
        open: true,
        message: data.message,
        severity: 'success',
      });
    } catch (error) {
      console.error('Error toggling auto-indexing:', error);
      setError('Failed to update auto-indexing status. Please try again later.');
      setSnackbar({
        open: true,
        message: 'Failed to update auto-indexing status',
        severity: 'error',
      });
    }
  };

  const handleVerifyOwnershipPermissions = async (websiteId: number) => {
    try {
      const response = await fetch(`/api/websites/${websiteId}/verify-ownership`, {
        method: 'GET',
      });
      if (!response.ok) {
        throw new Error('Failed to verify ownership permissions');
      }
      const data = await response.json();
      setWebsites(prevWebsites => 
        prevWebsites?.map(website => 
          website.id === websiteId ? { ...website, is_owner: data.is_owner } : website
        ) || null
      );
      setSnackbar({
        open: true,
        message: data.is_owner ? 'Ownership verified successfully' : 'Service account has no ownership permissions',
        severity: data.is_owner ? 'success' : 'error',
      });
    } catch (error) {
      console.error('Error verifying permissions:', error);
      setError('Failed to verify permissions. Please try again later.');
      setSnackbar({
        open: true,
        message: 'Failed to verify permissions',
        severity: 'error',
      });
    }
  };

  const handleRefresh = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/websites/refresh', { method: 'POST' });
      if (!response.ok) {
        throw new Error('Failed to refresh websites');
      }
      await fetchWebsites();
      setSnackbar({
        open: true,
        message: 'Websites refreshed successfully',
        severity: 'success',
      });
    } catch (error) {
      console.error('Error refreshing websites:', error);
      setError('Failed to refresh websites. Please try again later.');
      setSnackbar({
        open: true,
        message: 'Failed to refresh websites',
        severity: 'error',
      });
    } finally {
      setLoading(false);
    }
  };

  const handleChangePage = (event: unknown, newPage: number) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event: React.ChangeEvent<HTMLInputElement>) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const handleRequestSort = (property: keyof Website) => {
    const isAsc = orderBy === property && order === 'asc';
    setOrder(isAsc ? 'desc' : 'asc');
    setOrderBy(property);
  };

  const extractDomain = (input: string): string => {
    if (!input) return 'Unknown Domain';
    let domain = input.replace(/^sc-domain:/, '');
    domain = domain.replace(/^(https?:\/\/)?(www\.)?/, '');
    domain = domain.split('/')[0].split('?')[0];
    return domain;
  };

  const formatLastScanned = (date: Date | null): string => {
    if (!date) return 'Never';
    return new Date(date).toLocaleString();
  };

  const sortedWebsites = useMemo(() => {
    if (!websites) return [];
    return [...websites].sort((a, b) => {
      let valueA: any = a[orderBy];
      let valueB: any = b[orderBy];
      
      if (orderBy === 'domain') {
        valueA = extractDomain(valueA as string);
        valueB = extractDomain(valueB as string);
      } else if (orderBy === 'last_robots_scan') {
        valueA = valueA ? new Date(valueA as Date).getTime() : 0;
        valueB = valueB ? new Date(valueB as Date).getTime() : 0;
      }
      
      if (valueA < valueB) {
        return order === 'asc' ? -1 : 1;
      }
      if (valueA > valueB) {
        return order === 'asc' ? 1 : -1;
      }
      return 0;
    });
  }, [websites, order, orderBy]);

  const paginatedWebsites = useMemo(() => {
    const startIndex = page * rowsPerPage;
    return sortedWebsites.slice(startIndex, startIndex + rowsPerPage);
  }, [sortedWebsites, page, rowsPerPage]);

  const renderOwnershipChip = (isOwner: boolean | null) => {
    if (isOwner === null) {
      return <Chip label="Unknown" color="default" variant="outlined" />;
    }
    return isOwner ? (
      <Chip label="Owner" color="success" variant="outlined" />
    ) : (
      <Chip label="Not Owner" color="warning" variant="outlined" />
    );
  };

  if (loading && !websites) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Container sx={{ mt: 4 }}>
      <Grid container spacing={3} alignItems="center" sx={{ mb: 3 }}>
        <Grid item xs={12} sm={6}>
          <Typography variant="h4" component="h1" sx={{ fontSize: { xs: '1.5rem', sm: '2rem' } }}>
            Dashboard
          </Typography>
        </Grid>
        <Grid item xs={12} sm={6} sx={{ display: 'flex', justifyContent: { xs: 'flex-start', sm: 'flex-end' }, flexDirection: { xs: 'column', sm: 'row' } }}>
          <Button
            startIcon={<InfoIcon />}
            onClick={() => setModalOpen(true)}
            variant="outlined"
            color="secondary"
            sx={{ mr: { xs: 0, sm: 2 }, mb: { xs: 1, sm: 0 } }}
          >
            How to Enable Auto-indexing
          </Button>
          <Button
            startIcon={<RefreshIcon />}
            onClick={handleRefresh}
            variant="outlined"
          >
            Refresh from Google Search Console
          </Button>
        </Grid>
      </Grid>

      {websites && (
        <>
          {isMobile ? (
            // Mobile view
            <Box>
              {paginatedWebsites.map((website) => (
                <Card key={website.id} sx={{ mb: 2 }}>
                  <CardContent>
                    <Typography variant="subtitle1" sx={{ mb: 1, wordBreak: 'break-all' }}>
                      {extractDomain(website.domain)}
                    </Typography>
                    <Typography variant="body2">
                      Enabled: 
                      <Switch
                        checked={website.enabled}
                        onChange={() => handleToggleEnabled(website.id, website.enabled)}
                      />
                    </Typography>
                    <Typography variant="body2" sx={{ display: 'flex', alignItems: 'center', mt: 1 }}>
                      Permissions:&nbsp; {renderOwnershipChip(website.is_owner)}
                      <Tooltip title="Refresh Permissions">
                        <IconButton onClick={() => handleVerifyOwnershipPermissions(website.id)} size="small">
                          <RefreshIcon fontSize="small" />
                        </IconButton>
                      </Tooltip>
                    </Typography>
                    <Typography variant="body2">
                      Auto-indexing: 
                      <Switch
                        checked={website.auto_indexing_enabled}
                        onChange={() => handleToggleAutoIndexing(website.id, website.auto_indexing_enabled)}
                        disabled={!website.is_owner}
                      />
                    </Typography>
                    <Typography variant="body2">
                      Last Scanned: {formatLastScanned(website.last_robots_scan)}
                    </Typography>
                  </CardContent>
                </Card>
              ))}
            </Box>
          ) : (
            // Desktop view
            <TableContainer component={Paper}>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>
                      <TableSortLabel
                        active={orderBy === 'domain'}
                        direction={orderBy === 'domain' ? order : 'asc'}
                        onClick={() => handleRequestSort('domain')}
                      >
                        Website
                      </TableSortLabel>
                    </TableCell>
                    <TableCell>Enabled</TableCell>
                    <TableCell>Permissions</TableCell>
                    <TableCell>Auto-indexing</TableCell>
                    <TableCell>
                      <TableSortLabel
                        active={orderBy === 'last_robots_scan'}
                        direction={orderBy === 'last_robots_scan' ? order : 'asc'}
                        onClick={() => handleRequestSort('last_robots_scan')}
                      >
                        Last Scanned
                      </TableSortLabel>
                    </TableCell>
                  </TableRow>
                </TableHead>
                <TableBody>
                  {paginatedWebsites.map((website) => (
                    <TableRow key={website.id}>
                      <TableCell>
                        {website.enabled ? (
                          <Link href={`/website/${website.id}`} passHref>
                            <Typography 
                              component="a" 
                              sx={{ 
                                color: 'primary.main', 
                                textDecoration: 'none',
                                '&:hover': {
                                  textDecoration: 'underline',
                                },
                              }}
                            >
                              {extractDomain(website.domain)}
                            </Typography>
                          </Link>
                        ) : (
                          extractDomain(website.domain)
                        )}
                      </TableCell>
                      <TableCell>
                        <Switch
                          checked={website.enabled}
                          onChange={() => handleToggleEnabled(website.id, website.enabled)}
                        />
                      </TableCell>
                      <TableCell>
                        {renderOwnershipChip(website.is_owner)}
                        <Tooltip title="Refresh Permissions">
                          <IconButton onClick={() => handleVerifyOwnershipPermissions(website.id)} size="small">
                            <RefreshIcon fontSize="small" />
                          </IconButton>
                        </Tooltip>
                      </TableCell>
                      <TableCell>
                        <Switch
                          checked={website.auto_indexing_enabled}
                          onChange={() => handleToggleAutoIndexing(website.id, website.auto_indexing_enabled)}
                          disabled={!website.is_owner}
                        />
                      </TableCell>
                      <TableCell>{formatLastScanned(website.last_robots_scan)}</TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          )}
          <TablePagination
            rowsPerPageOptions={[10, 25, 50, 100]}
            component="div"
            count={sortedWebsites.length}
            rowsPerPage={rowsPerPage}
            page={page}
            onPageChange={handleChangePage}
            onRowsPerPageChange={handleChangeRowsPerPage}
          />
        </>
      )}

      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={() => setSnackbar({ ...snackbar, open: false })}
          severity={snackbar.severity}
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
      <PermissionsModal
        open={modalOpen}
        onClose={() => setModalOpen(false)}
        serviceAccountEmail={serviceAccountEmail}
      />
    </Container>
  );
};

export default WithAuth(Dashboard);

// Filename: app/globals.css
/* global.css */

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
  --max-width: 1100px;
  --border-radius: 12px;
  --font-mono: ui-monospace, Menlo, Monaco, 'Cascadia Mono', 'Segoe UI Mono',
    'Roboto Mono', 'Oxygen Mono', 'Ubuntu Monospace', 'Source Code Pro',
    'Fira Mono', 'Droid Sans Mono', 'Courier New', monospace;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
  font-family: 'Inter', sans-serif;
}

a {
  color: inherit;
  text-decoration: none;
}

/* Custom scrollbar styles */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #555;
}


// Filename: app/layout.tsx
// Filename: app/layout.tsx

'use client';

import React, { useState } from 'react';
import { SessionProvider } from 'next-auth/react';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { Box } from '@mui/material';
import Navigation from '@/components/Navigation';
import Sidebar from '@/components/Sidebar';
import ErrorBoundary from '@/components/ErrorBoundary';
import ErrorHandler from '@/components/ErrorHandler';
import { usePathname } from 'next/navigation';
import theme from '@/lib/theme';
import { ErrorContext } from '@/lib/ErrorContext';

export interface RootLayoutProps {
  children: React.ReactNode;
}

export default function RootLayout({ children }: RootLayoutProps) {
  const [error, setError] = useState<string | null>(null);
  const [mobileOpen, setMobileOpen] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(280); // Initial sidebar width
  const pathname = usePathname();
  const isSignInPage = pathname === '/auth/signin';

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleSidebarResize = (newWidth: number) => {
    setSidebarWidth(newWidth);
  };

  const handleCloseError = () => {
    setError(null);
  };

  return (
    <html lang="en">
      <body>
        <SessionProvider>
          <ThemeProvider theme={theme}>
            <CssBaseline />
            <ErrorContext.Provider value={{ setError }}>
              <ErrorBoundary>
                {!isSignInPage && (
                  <Box sx={{ display: 'flex', height: '100vh' }}>
                    {/* Navigation Bar */}
                    <Navigation sidebarWidth={sidebarWidth} onMenuClick={handleDrawerToggle} />

                    {/* Sidebar */}
                    <Sidebar
                      open={mobileOpen}
                      onClose={handleDrawerToggle}
                      sidebarWidth={sidebarWidth}
                      onSidebarResize={handleSidebarResize}
                    />

                    {/* Main Content Area */}
                    <Box
                      component="main"
                      sx={{
                        flexGrow: 1,
                        p: 3,
                        width: { sm: `calc(100% - ${sidebarWidth}px)` },
                        mt: '64px', // Offset for the AppBar (Navigation)
                      }}
                    >
                      {children}
                    </Box>
                  </Box>
                )}
                {isSignInPage && children}
                <ErrorHandler error={error} onClose={handleCloseError} />
              </ErrorBoundary>
            </ErrorContext.Provider>
          </ThemeProvider>
        </SessionProvider>
      </body>
    </html>
  );
}


// Filename: app/page.tsx
'use client';

import React, { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useSession } from 'next-auth/react';
import { CircularProgress } from '@mui/material';

const HomeClient: React.FC = () => {
  const { status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === 'authenticated') {
      router.push('/dashboard');
    } else if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  if (status === 'loading') {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
      </div>
    );
  }

  // Return null while waiting for redirect
  return null;
};

export default HomeClient;

// Filename: app/website/[websiteId]/page.tsx
// File: app/website/[websiteId]/page.tsx

'use client';

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  Box,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  CircularProgress,
  TablePagination,
  TableSortLabel,
  useTheme,
  useMediaQuery,
  Button,
  Grid,
  Card,
  CardContent,
  Snackbar,
} from '@mui/material';
import MuiAlert, { AlertProps } from '@mui/material/Alert';
import { SyncAlt as SyncIcon } from '@mui/icons-material';
import { Website, Page } from '@/types';
import { useError } from '@/lib/useError';
import IndexingStats from '@/components/IndexingStats';

type SortableColumn = keyof Page | "impressions" | "clicks";
type Order = 'asc' | 'desc';

interface HeadCell {
  id: keyof Page | 'impressions' | 'clicks' | 'actions';
  label: string;
  numeric: boolean;
  sortable: boolean;
}

const headCells: HeadCell[] = [
  { id: 'url', label: 'URL', numeric: false, sortable: true },
  { id: 'indexing_status', label: 'Status', numeric: false, sortable: true },
  { id: 'last_indexed_date', label: 'Last Crawled', numeric: false, sortable: true },
  { id: 'impressions', label: 'Impressions', numeric: true, sortable: true },
  { id: 'clicks', label: 'Clicks', numeric: true, sortable: true },
  { id: 'actions', label: 'Actions', numeric: false, sortable: false },
];

const Alert = React.forwardRef<HTMLDivElement, AlertProps>(function Alert(
  props,
  ref,
) {
  return <MuiAlert elevation={6} ref={ref} variant="filled" {...props} />;
});

const indexed: string = 'Submitted and indexed';

export default function WebsiteDetailsPage({ params }: { params: { websiteId: string } }) {
  const websiteId = parseInt(params.websiteId);
  const [website, setWebsite] = useState<Website | null>(null);
  const [allPages, setAllPages] = useState<Page[]>([]);
  const [loading, setLoading] = useState(true);
  const [syncing, setSyncing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [order, setOrder] = useState<Order>('asc');
  const [orderBy, setOrderBy] = useState<SortableColumn>('indexing_status');
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(25);
  const [metricsData, setmetricsData] = useState<{ [key: string]: { impressions: number, clicks: number } }>({});
  const [submitting, setSubmitting] = useState<number | null>(null);
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' }>({
    open: false,
    message: '',
    severity: 'success',
  });
  const [initialScanTime, setInitialScanTime] = useState<string | null>(null);
  const [isPolling, setIsPolling] = useState(false);
  const [pollingAttempts, setPollingAttempts] = useState(0);
  const MAX_POLLING_ATTEMPTS = 3;

  const setGlobalError = useError();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const cleanDomain = (domain: string): string => {
    return domain.replace(/^(sc-domain:)?(https?:\/\/)?(www\.)?/, '');
  };

  const formatLastCrawled = (date: Date | null): string => {
    return date ? new Date(date).toLocaleString() : 'Not crawled yet';
  };

  const isSortableColumn = (id: string): id is SortableColumn => {
    return id !== 'actions';
  };

  const canSubmitForIndexing = (lastIndexedDate: Date | null): boolean => {
    if (!lastIndexedDate) return true; // If never indexed, allow submission
    const twentyFourHoursAgo = Date.now() - 24 * 60 * 60 * 1000;
    return new Date(lastIndexedDate).getTime() <= twentyFourHoursAgo;
  };

  const fetchWebsiteDetails = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const websiteResponse = await fetch(`/api/websites/${websiteId}`);
      if (!websiteResponse.ok) {
        throw new Error('Failed to fetch website details');
      }
      const websiteData = await websiteResponse.json();
      setWebsite(websiteData);

      const pagesResponse = await fetch(`/api/websites/${websiteId}/pages?all=true`);
      if (!pagesResponse.ok) {
        throw new Error('Failed to fetch pages');
      }
      const pagesData = await pagesResponse.json();
      setAllPages(pagesData.pages || []);

      const urls = pagesData.pages.map((p: Page) => p.url);
      const metricsResponse = await fetch(`/api/websites/${websiteId}/metrics`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ urls }),
      });
      if (!metricsResponse.ok) {
        throw new Error('Failed to fetch metrics data');
      }
      const metricsData = await metricsResponse.json();
      setmetricsData(metricsData.data);

    } catch (err) {
      console.error('Error fetching website details:', err);
      setError('An error occurred while fetching website details');
      setGlobalError('Failed to load website details. Please try again later.');

    } finally {
      setLoading(false);
    }
  }, [websiteId, setGlobalError]);

  const handleRequestSort = (property: keyof Page | "impressions" | "clicks" | "actions") => {
    if (isSortableColumn(property)) {
      const isAsc = orderBy === property && order === 'asc';
      setOrder(isAsc ? 'desc' : 'asc');
      setOrderBy(property);
    }
  };

  const handleChangePage = (event: unknown, newPage: number) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event: React.ChangeEvent<HTMLInputElement>) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const handleSubmitForIndexing = async (pageId: number) => {
    try {
      setSubmitting(pageId);
      const response = await fetch(`/api/websites/${websiteId}/pages/${pageId}/submit-for-indexing`, {
        method: 'POST',
      });

      if (!response.ok) {
        throw new Error('Failed to submit page for indexing');
      }

      const result = await response.json();
      setGlobalError(null);
      setSnackbar({
        open: true,
        message: result.message || 'Page submitted for indexing successfully',
        severity: 'success',
      });

      // Refresh the page data
      fetchWebsiteDetails();

    } catch (err) {
      console.error('Error submitting page for indexing:', err);
      setGlobalError('Failed to submit page for indexing. Please try again later.');
      setSnackbar({
        open: true,
        message: 'Failed to submit page for indexing',
        severity: 'error',
      });

    } finally {
      setSubmitting(null);
    }
  };

  const handleSyncPages = async () => {
    try {
      setSyncing(true);
      setPollingAttempts(0);

      const response = await fetch(`/api/websites/${websiteId}/toggle`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ enabled: true }),
      });

      if (!response.ok) {
        throw new Error('Failed to sync pages');
      }

      const data = await response.json();
      console.log(data);

      setInitialScanTime(data.initialScanTime);
      setIsPolling(true);
      setSnackbar({
        open: true,
        message: 'Sync pages started',
        severity: 'success',
      });

    } catch (err) {
      console.error('Error syncing pages:', err);
      setGlobalError('Failed to sync pages. Please try again later.');
      setSnackbar({
        open: true,
        message: 'Failed to sync pages',
        severity: 'error',
      });

    } finally {
      setSyncing(false);
    }
  };

  const checkJobStatus = useCallback(async () => {
    if (!initialScanTime) return;
  
    try {
      const response = await fetch(`/api/websites/${websiteId}/toggle?initialScanTime=${initialScanTime}`);
      if (!response.ok) {
        throw new Error('Failed to check sync status');
      }
      const data = await response.json();
      
      if (data.isCompleted) {
        setIsPolling(false);
        await fetchWebsiteDetails();
        setSnackbar({
          open: true,
          message: 'Pages sync completed',
          severity: 'success',
        });
      } else {
        setPollingAttempts(prevAttempts => prevAttempts + 1);
        if (pollingAttempts >= MAX_POLLING_ATTEMPTS) {
          setIsPolling(false);
        }
      }
    } catch (error) {
      console.error('Error checking sync status:', error);
      setIsPolling(false);
      setSnackbar({
        open: true,
        message: 'Error checking sync status',
        severity: 'error',
      });
    }
  }, [initialScanTime, websiteId, fetchWebsiteDetails, pollingAttempts]);

  useEffect(() => {
    fetchWebsiteDetails();
  }, [fetchWebsiteDetails]);

  useEffect(() => {
    let intervalId: NodeJS.Timeout;
  
    if (isPolling && pollingAttempts < MAX_POLLING_ATTEMPTS) {
      intervalId = setInterval(checkJobStatus, 5000); // Poll every 5 seconds
    } else if (pollingAttempts >= MAX_POLLING_ATTEMPTS) {
      setIsPolling(false);
    }
  
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isPolling, checkJobStatus, pollingAttempts]);

  useEffect(() => {
    if (!isPolling) {
      fetchWebsiteDetails();
    }
  }, [isPolling, fetchWebsiteDetails]);

  const getSubmitButtonColor = (status: string) => {
    return status !== indexed ? theme.palette.error.light : theme.palette.primary.main;
  };

  const sortedAndPaginatedPages = useMemo(() => {
    const sortedPages = [...allPages].sort((a, b) => {
      const aValue = orderBy === 'impressions' || orderBy === 'clicks' 
        ? (metricsData[a.url]?.[orderBy] || 0) 
        : a[orderBy as keyof Page];
      const bValue = orderBy === 'impressions' || orderBy === 'clicks'
        ? (metricsData[b.url]?.[orderBy] || 0)
        : b[orderBy as keyof Page];

      if (typeof aValue === 'string' && typeof bValue === 'string') {
        return order === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
      } else if (aValue instanceof Date && bValue instanceof Date) {
        return order === 'asc' ? aValue.getTime() - bValue.getTime() : bValue.getTime() - aValue.getTime();
      } else if (typeof aValue === 'number' && typeof bValue === 'number') {
        return order === 'asc' ? aValue - bValue : bValue - aValue;
      }
      return 0;
    });

    const startIndex = page * rowsPerPage;
    const endIndex = startIndex + rowsPerPage;
    return sortedPages.slice(startIndex, endIndex);
  }, [allPages, order, orderBy, metricsData, page, rowsPerPage]);

  if (loading && allPages.length === 0) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
        <CircularProgress />
      </Box>);
  }

  if (error) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
        <Alert severity="error">{error}</Alert>
      </Box>
    );
  }

  return (
    <Box sx={{ flexGrow: 1, p: 3 }}>
      <Grid container spacing={3} alignItems="center" sx={{ mb: 3 }}>
        <Grid item xs={12} sm={6}>
          <Typography variant="h4" component="h1">
            {website ? cleanDomain(website.domain) : 'Website Details'}
          </Typography>
        </Grid>
        <Grid item xs={12} sm={6} sx={{ display: 'flex', justifyContent: 'flex-end' }}>
          <Button
            variant="outlined"
            startIcon={syncing ? <CircularProgress size={20} color="inherit" /> : <SyncIcon />}
            onClick={handleSyncPages}
            disabled={syncing || isPolling}
          >
            {syncing ? 'Syncing...' : isPolling ? 'Sync in progress...' : 'Sync Pages'}
          </Button>
        </Grid>
      </Grid>

      <IndexingStats websiteId={websiteId} />

      <Typography variant="h5" gutterBottom sx={{ mt: 4, mb: 2 }}>
        Pages
      </Typography>

      {allPages.length > 0 ? (
        <Paper>
          {isMobile ? (
            // Mobile view
            <Box>
              {sortedAndPaginatedPages.map((page) => (
                <Card key={page.id} sx={{ mb: 2 }}>
                  <CardContent>
                    <Typography variant="subtitle1" sx={{ mb: 1, wordBreak: 'break-all' }}>
                      {page.url}
                    </Typography>
                    <Typography variant="body2">Status: {page.indexing_status}</Typography>
                    <Typography variant="body2">
                      Last Crawled: {formatLastCrawled(page.last_indexed_date)}
                    </Typography>
                    <Typography variant="body2">
                      Impressions: {metricsData[page.url]?.impressions || 0}
                    </Typography>
                    <Typography variant="body2">
                      Clicks: {metricsData[page.url]?.clicks || 0}
                    </Typography>
                    <Button
                      variant="contained"
                      size="small"
                      onClick={() => handleSubmitForIndexing(page.id)}
                      disabled={
                        submitting === page.id ||
                        !canSubmitForIndexing(page.last_indexed_date)
                      }
                      sx={{ 
                        mt: 1, 
                        backgroundColor: getSubmitButtonColor(page.indexing_status),
                        '&:hover': {
                          backgroundColor: theme.palette.error.main,
                        },
                      }}
                    >
                      {submitting === page.id ? <CircularProgress size={24} /> : 'Submit'}
                    </Button>
                  </CardContent>
                </Card>
              ))}
            </Box>
          ) : (
            // Desktop view
            <TableContainer>
              <Table sx={{ minWidth: 300 }} aria-label="website pages table">
                <TableHead>
                  <TableRow>
                    {headCells.map((headCell) => (
                      <TableCell
                        key={headCell.id}
                        align={headCell.numeric ? 'right' : 'left'}
                        sortDirection={orderBy === headCell.id ? order : false}
                      >
                        {headCell.sortable ? (
                          <TableSortLabel
                            active={orderBy === headCell.id}
                            direction={orderBy === headCell.id ? order : 'asc'}
                            onClick={() => handleRequestSort(headCell.id)}
                          >
                            {headCell.label}
                          </TableSortLabel>
                        ) : (
                          headCell.label
                        )}
                      </TableCell>
                    ))}
                  </TableRow>
                </TableHead>
                <TableBody>
                  {sortedAndPaginatedPages.map((page) => (
                    <TableRow key={page.id}>
                      <TableCell
                        component="th"
                        scope="row"
                        sx={{
                          maxWidth: 300,
                          overflow: 'hidden',
                          textOverflow: 'ellipsis',
                          whiteSpace: 'nowrap',
                        }}
                      >
                        {page.url}
                      </TableCell>
                      <TableCell>{page.indexing_status}</TableCell>
                      <TableCell>{formatLastCrawled(page.last_indexed_date)}</TableCell>
                      <TableCell align="right">{metricsData[page.url]?.impressions || 0}</TableCell>
                      <TableCell align="right">{metricsData[page.url]?.clicks || 0}</TableCell>
                      <TableCell>
                        <Button
                          variant="contained"
                          size="small"
                          onClick={() => handleSubmitForIndexing(page.id)}
                          disabled={
                            submitting === page.id ||
                            !canSubmitForIndexing(page.last_indexed_date)
                          }
                          sx={{ 
                            backgroundColor: getSubmitButtonColor(page.indexing_status),
                            '&:hover': {
                              backgroundColor: theme.palette.error.main,
                            },
                          }}
                        >
                          {submitting === page.id ? <CircularProgress size={24} /> : 'Submit'}
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          )}
          <TablePagination
            rowsPerPageOptions={[10, 25, 50, 100]}
            component="div"
            count={allPages.length}
            rowsPerPage={rowsPerPage}
            page={page}
            onPageChange={handleChangePage}
            onRowsPerPageChange={handleChangeRowsPerPage}
          />
        </Paper>
      ) : (
        <Alert severity="info">No pages found for this website.</Alert>
      )}
  
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={() => setSnackbar({ ...snackbar, open: false })}
          severity={snackbar.severity}
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
}

// Filename: combine.js
const fs = require('fs');
const path = require('path');

const outputFile = 'all-code.txt';
const extensions = ['.js', '.ts', '.tsx', '.css', '.env'];   // file extensions to include
const excludedDirs = ['node_modules', '.next'];              // Directories to exclude

function combineFiles(dir) {
  // Skip the directory if it's in the excluded list
  if (excludedDirs.includes(path.basename(dir))) {
    return;
  }

  fs.readdirSync(dir).forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      combineFiles(fullPath);
    } else if (extensions.includes(path.extname(fullPath))) {
      // Get the relative path of the file
      const relativePath = path.relative(__dirname, fullPath);

      // Read the file content
      let data = fs.readFileSync(fullPath, 'utf8');

      // Add the path and filename as a comment in the first line
      data = `// Filename: ${relativePath}\n${data}`;

      // Add an empty line at the end of the file content
      data = `${data}\n`;

      // Append the modified data to the output file
      fs.appendFileSync(outputFile, `\n${data}`);
    }
  });
}

// Clear the output file if it exists
fs.writeFileSync(outputFile, '', 'utf8');

// Start combining from the current directory
combineFiles(__dirname);


// Filename: components/AnalyticsSummary.tsx
import React, { useState, useEffect } from 'react';
import { Grid, Paper, Typography } from '@mui/material';

interface AnalyticsData {
  totalVisits: number;
  averageSessionDuration: string;
  bounceRate: string;
}

const AnalyticsSummary: React.FC = () => {
  const [analyticsData, setAnalyticsData] = useState<AnalyticsData | null>(null);

  useEffect(() => {
    fetchAnalyticsData();
  }, []);

  const fetchAnalyticsData = async () => {
    try {
      const response = await fetch('/api/analytics/summary');
      const data = await response.json();
      setAnalyticsData(data);
    } catch (error) {
      console.error('Error fetching analytics data:', error);
    }
  };

  if (!analyticsData) {
    return <Typography>Loading analytics data...</Typography>;
  }

  return (
    <Grid container spacing={3}>
      <Grid item xs={4}>
        <Paper elevation={2} sx={{ p: 2, textAlign: 'center' }}>
          <Typography variant="h6">{analyticsData.totalVisits}</Typography>
          <Typography variant="body2">Total Visits</Typography>
        </Paper>
      </Grid>
      <Grid item xs={4}>
        <Paper elevation={2} sx={{ p: 2, textAlign: 'center' }}>
          <Typography variant="h6">{analyticsData.averageSessionDuration}</Typography>
          <Typography variant="body2">Avg. Session Duration</Typography>
        </Paper>
      </Grid>
      <Grid item xs={4}>
        <Paper elevation={2} sx={{ p: 2, textAlign: 'center' }}>
          <Typography variant="h6">{analyticsData.bounceRate}%</Typography>
          <Typography variant="body2">Bounce Rate</Typography>
        </Paper>
      </Grid>
    </Grid>
  );
};

export default AnalyticsSummary;

// Filename: components/ErrorBoundary.tsx
// File: components/ErrorBoundary.tsx
import React, { Component, ErrorInfo } from 'react';
import { AppError } from '@/utils/errors';

interface Props {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }
      return (
        <div>
          <h1>Something went wrong</h1>
          <p>{this.state.error instanceof AppError ? this.state.error.message : 'An unexpected error occurred'}</p>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

// Filename: components/ErrorHandler.tsx
// components/ErrorHandler.tsx
import React from 'react';
import { Alert, AlertTitle, Snackbar } from '@mui/material';

interface ErrorHandlerProps {
  error: string | null;
  onClose: () => void;
}

const ErrorHandler: React.FC<ErrorHandlerProps> = ({ error, onClose }) => {
  return (
    <Snackbar open={!!error} autoHideDuration={6000} onClose={onClose}>
      <Alert onClose={onClose} severity="error" sx={{ width: '100%' }}>
        <AlertTitle>Error</AlertTitle>
        {error}
      </Alert>
    </Snackbar>
  );
};

export default ErrorHandler;

// Filename: components/IndexingStats.tsx
// Filename: components/IndexingStats.tsx

import React, { useState, useEffect, useCallback } from 'react';
import { Grid, Typography, Paper, Alert } from '@mui/material';
import { IndexingStatsData } from '@/types';

interface IndexingStatsProps {
  websiteId: number;
}

const IndexingStats: React.FC<IndexingStatsProps> = ({ websiteId }) => {
  const [indexingStats, setIndexingStats] = useState<IndexingStatsData | null>(null);
  const [error, setError] = useState<string | null>(null);

  const fetchIndexingStats = useCallback(async () => {
    try {
      setError(null);

      const response = await fetch(`/api/websites/${websiteId}/indexing-stats`);
      if (!response.ok) {
        throw new Error('Failed to fetch indexing stats');
      }

      const data = await response.json();
      setIndexingStats(data.indexingStats?.indexingStats || null);

    } catch (err) {
      console.error('Error fetching indexing stats:', err);
      setError('An error occurred while fetching indexing stats');
    }
  }, [websiteId]);

  
  useEffect(() => {
    fetchIndexingStats();
  }, [fetchIndexingStats]);


  if (error) {
    return <Alert severity="error">{error}</Alert>;
  }

  return (
    <Paper elevation={3} sx={{ p: 3, mb: 4 }}>
      <Grid container spacing={2}>
        <Grid item xs={12} sm={6} md={3}>
          <Typography variant="subtitle1">Total Pages</Typography>
          <Typography variant="h6">{indexingStats?.total_pages || 0}</Typography>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Typography variant="subtitle1">Indexed Pages</Typography>
          <Typography variant="h6">{indexingStats?.indexed_pages || 0}</Typography>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Typography variant="subtitle1">Not Indexed Pages</Typography>
          <Typography variant="h6">{indexingStats?.not_indexed_pages || 0}</Typography>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Typography variant="subtitle1">Auto-indexing</Typography>
          <Typography variant="h6">Enabled</Typography>
        </Grid>
      </Grid>
    </Paper>
  );
};

export default IndexingStats;


// Filename: components/Navigation.tsx
// Filename: components/Navigation.tsx

import React from 'react';
import { AppBar, Toolbar, Typography, IconButton, Button } from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import { useSession, signOut } from 'next-auth/react';

interface NavigationProps {
  sidebarWidth: number;
  onMenuClick: () => void;
}

const Navigation: React.FC<NavigationProps> = ({ sidebarWidth, onMenuClick }) => {
  const { data: session } = useSession();

  return (
    <AppBar
      position="fixed"
      sx={{
        zIndex: (theme) => theme.zIndex.drawer + 1,
        width: { sm: `calc(100% - ${sidebarWidth}px)` },
        ml: { sm: `${sidebarWidth}px` },
      }}
    >
      <Toolbar>
        <IconButton
          color="inherit"
          aria-label="open drawer"
          edge="start"
          onClick={onMenuClick}
          sx={{ mr: 2, display: { sm: 'none' } }}
        >
          <MenuIcon />
        </IconButton>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          {/* Placeholder for alignment */}
        </Typography>
        {session ? (
          <>
            <Typography variant="body1" sx={{ marginRight: 2 }}>
              {session.user?.name}
            </Typography>
            <Button color="inherit" onClick={() => signOut()}>
              Logout
            </Button>
          </>
        ) : null}
      </Toolbar>
    </AppBar>
  );
};

export default Navigation;


// Filename: components/PermissionsModal.tsx
import React, { useState } from 'react';
import { 
  Dialog, 
  DialogTitle, 
  DialogContent, 
  DialogActions, 
  Button, 
  Typography, 
  Link, 
  Box, 
  IconButton, 
  Tooltip,
  Snackbar,
  useTheme,
  useMediaQuery
} from '@mui/material';
import { Launch as LaunchIcon, ContentCopy as ContentCopyIcon } from '@mui/icons-material';
import MuiAlert, { AlertProps } from '@mui/material/Alert';

interface PermissionsModalProps {
  open: boolean;
  onClose: () => void;
  serviceAccountEmail: string;
}

export const PermissionsModal: React.FC<PermissionsModalProps> = ({
  open,
  onClose,
  serviceAccountEmail
}) => {
  const [copySuccess, setCopySuccess] = useState(false);
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const handleCopyEmail = async () => {
    try {
      await navigator.clipboard.writeText(serviceAccountEmail);
      setCopySuccess(true);
    } catch (err) {
      console.error('Failed to copy text: ', err);
    }
  };

  const handleCloseCopySuccess = (event?: React.SyntheticEvent | Event, reason?: string) => {
    if (reason === 'clickaway') {
      return;
    }
    setCopySuccess(false);
  };

  const Alert = React.forwardRef<HTMLDivElement, AlertProps>(function Alert(
    props,
    ref,
  ) {
    return <MuiAlert elevation={6} ref={ref} variant="filled" {...props} />;
  });

  return (
    <Dialog 
      open={open} 
      onClose={onClose} 
      maxWidth="sm" 
      fullWidth
      fullScreen={isMobile}
    >
      <DialogTitle sx={{ fontSize: { xs: '1.2rem', sm: '1.5rem' } }}>
        Permissions needed for Auto-Indexing
      </DialogTitle>
      <DialogContent>
        <Typography paragraph>
          To activate the service account, please add the following email to your Google Search Console users:
        </Typography>
        <Box sx={{ 
          my: 2, 
          p: 2, 
          bgcolor: 'grey.100', 
          borderRadius: 1, 
          display: 'flex', 
          flexDirection: { xs: 'column', sm: 'row' },
          alignItems: { xs: 'flex-start', sm: 'center' }, 
          justifyContent: 'space-between'
        }}>
          <Typography 
            variant="body2" 
            sx={{ 
              fontWeight: 'bold', 
              wordBreak: 'break-all', 
              mr: { xs: 0, sm: 2 },
              mb: { xs: 1, sm: 0 }
            }}
          >
            {serviceAccountEmail || 'Service account email not available'}
          </Typography>
          <Tooltip title="Copy email">
            <IconButton onClick={handleCopyEmail} size="small">
              <ContentCopyIcon fontSize="small" />
            </IconButton>
          </Tooltip>
        </Box>
        <Typography paragraph>
          The user must be added with Owner permission.
        </Typography>
        <Button
          variant="outlined"
          color="primary"
          startIcon={<LaunchIcon />}
          component={Link}
          href="https://search.google.com/search-console"
          target="_blank"
          rel="noopener noreferrer"
          fullWidth
          sx={{ mb: 2 }}
        >
          Open Google Search Console
        </Button>
        <Typography variant="body2" color="text.secondary">
          After adding the service account, click the &quot;Refresh Permissions&quot; button to verify it.
        </Typography>
      </DialogContent>
      <DialogActions sx={{ flexDirection: { xs: 'column', sm: 'row' }, padding: { xs: 2, sm: 1 } }}>
        <Button 
          onClick={onClose} 
          variant="contained"
          fullWidth={isMobile}
          sx={{ mb: { xs: 1, sm: 0 } }}
        >
          Close
        </Button>
      </DialogActions>
      <Snackbar open={copySuccess} autoHideDuration={3000} onClose={handleCloseCopySuccess}>
        <Alert onClose={handleCloseCopySuccess} severity="success" sx={{ width: '100%' }}>
          Email copied to clipboard!
        </Alert>
      </Snackbar>
    </Dialog>
  );
};

export default PermissionsModal;

// Filename: components/Sidebar.tsx
import React, { useState, useEffect } from 'react';
import { Box, Drawer, List, ListItem, ListItemButton, ListItemIcon, ListItemText, IconButton, CircularProgress, useTheme, useMediaQuery } from '@mui/material';
import { Dashboard as DashboardIcon, Web as WebIcon, Close as CloseIcon } from '@mui/icons-material';
import Link from 'next/link';
import Image from 'next/image';
import { Website } from '@/types';

interface SidebarProps {
  open: boolean;
  onClose?: () => void;
  sidebarWidth: number;
  onSidebarResize: (newWidth: number) => void;
}

const MOBILE_SIDEBAR_WIDTH = 280; // Fixed width for mobile

const Sidebar: React.FC<SidebarProps> = ({ open, onClose, sidebarWidth, onSidebarResize }) => {
  const [websites, setWebsites] = useState<Website[]>([]);
  const [loading, setLoading] = useState(true);
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  useEffect(() => {
    fetchWebsites();
  }, []);

  const fetchWebsites = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/websites');
      if (!response.ok) {
        throw new Error('Failed to fetch websites');
      }
      const data = await response.json();
      setWebsites(data.filter((website: Website) => website.enabled));
    } catch (error) {
      console.error('Error fetching websites:', error);
    } finally {
      setLoading(false);
    }
  };

  const extractDomainName = (domain: string) => {
    return domain.replace(/^sc-domain:/, '').replace(/^https?:\/\//, '').replace(/^www\./, '');
  };

  const handleMouseDown = (e: React.MouseEvent) => {
    if (isMobile) return; // Disable resizing on mobile
    e.preventDefault();
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (isMobile) return; // Disable resizing on mobile
    const newWidth = Math.max(200, e.clientX); // Set a minimum sidebar width
    onSidebarResize(newWidth);
  };

  const handleMouseUp = () => {
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
  };

  const drawerContent = (
    <Box sx={{ width: isMobile ? MOBILE_SIDEBAR_WIDTH : sidebarWidth, height: '100%', display: 'flex', flexDirection: 'column', position: 'relative', overflow: 'hidden' }}>
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          padding: 2,
          height: '64px',
          position: 'relative',
        }}
      >
        <Link href="/" passHref>
          <Image src="/images/logo.png" alt="App Logo" width={180} height={40} style={{ cursor: 'pointer' }} priority />
        </Link>
        {onClose && (
          <IconButton onClick={onClose} sx={{ position: 'absolute', right: 8, display: { sm: 'none' } }}>
            <CloseIcon />
          </IconButton>
        )}
      </Box>

      <List>
        <Link href="/dashboard" passHref legacyBehavior>
          <ListItem component="a" disablePadding>
            <ListItemButton>
              <ListItemIcon>
                <DashboardIcon />
              </ListItemIcon>
              <ListItemText primary="Dashboard" sx={{ color: 'primary.main' }} />
            </ListItemButton>
          </ListItem>
        </Link>
      </List>

      <List>
        <ListItem>
          <ListItemText primary="Auto-Indexed Websites" />
        </ListItem>
        {loading ? (
          <ListItem>
            <CircularProgress size={24} />
          </ListItem>
        ) : websites.length > 0 ? (
          websites.map((website) => (
            <Link href={`/website/${website.id}`} passHref key={website.id} legacyBehavior>
              <ListItem component="a" disablePadding>
                <ListItemButton>
                  <ListItemIcon>
                    <WebIcon />
                  </ListItemIcon>
                  <ListItemText primary={extractDomainName(website.domain)} sx={{ color: 'primary.main' }} />
                </ListItemButton>
              </ListItem>
            </Link>
          ))
        ) : (
          <ListItem>
            <ListItemText primary="No enabled websites" />
          </ListItem>
        )}
      </List>

      {/* Resizable handle only visible for desktop sidebar */}
      {!isMobile && (
        <Box
          sx={{
            width: '5px',
            cursor: 'col-resize',
            position: 'absolute',
            right: 0,
            top: 0,
            height: '100vh',
            zIndex: 1000,
            backgroundColor: 'transparent',
          }}
          onMouseDown={handleMouseDown}
        />
      )}
    </Box>
  );

  return (
    <Box component="nav" sx={{ width: { sm: isMobile ? MOBILE_SIDEBAR_WIDTH : sidebarWidth }, flexShrink: { sm: 0 } }}>
      {/* Mobile Sidebar */}
      <Drawer
        variant="temporary"
        open={open}
        onClose={onClose}
        ModalProps={{ keepMounted: true }}
        sx={{
          display: { xs: 'block', sm: 'none' },
          zIndex: (theme) => theme.zIndex.drawer + 2,
          '& .MuiDrawer-paper': { boxSizing: 'border-box', width: MOBILE_SIDEBAR_WIDTH, overflow: 'hidden' },
        }}
      >
        {drawerContent}
      </Drawer>

      {/* Desktop Sidebar */}
      <Drawer
        variant="permanent"
        sx={{
          display: { xs: 'none', sm: 'block' },
          '& .MuiDrawer-paper': { boxSizing: 'border-box', width: sidebarWidth, overflow: 'hidden' },
        }}
        open
      >
        {drawerContent}
      </Drawer>
    </Box>
  );
};

export default Sidebar;

// Filename: components/WebsiteList.tsx
import React from 'react';
import { 
  List, 
  ListItem, 
  ListItemText, 
  ListItemSecondaryAction, 
  Switch, 
  Typography, 
  Button 
} from '@mui/material';
import { Refresh as RefreshIcon } from '@mui/icons-material';
import { Website } from '@/types';

interface WebsiteListProps {
  websites: Website[];
  onToggleIndexing: (websiteId: number, currentStatus: boolean) => Promise<void>;
  onRefresh: () => Promise<void>;
}

const WebsiteList: React.FC<WebsiteListProps> = ({ websites, onToggleIndexing, onRefresh }) => {
  const handleToggle = async (websiteId: number, currentStatus: boolean) => {
    await onToggleIndexing(websiteId, currentStatus);
  };

  const formatLastScanned = (date: Date | null | undefined): string => {
    if (!date) return 'None';
    const formattedDate = new Date(date).toLocaleString();
    return formattedDate !== 'Invalid Date' ? formattedDate : 'None';
  };

  return (
    <>
      <Button
        startIcon={<RefreshIcon />}
        onClick={onRefresh}
        variant="outlined"
        style={{ marginBottom: '1rem' }}
      >
        Refresh from Search Console
      </Button>
      <List>
        {websites.map((website) => (
          <ListItem key={website.id} component="div">
            <ListItemText 
              primary={website.domain}
              secondary={`Last scanned: ${formatLastScanned(website.last_robots_scan)}`}
            />
            <ListItemSecondaryAction>
              <Switch
                edge="end"
                onChange={() => handleToggle(website.id, website.auto_indexing_enabled)}
                checked={website.auto_indexing_enabled}
              />
            </ListItemSecondaryAction>
          </ListItem>
        ))}
        {websites.length === 0 && (
          <Typography variant="body2" color="textSecondary" align="center">
            No websites found. Click &quote;Refresh from Search Console&quote; to fetch your properties.
          </Typography>
        )}
      </List>
    </>
  );
};

export default WebsiteList;

// Filename: components/WithAuth.tsx
'use client';

import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';
import { CircularProgress, Box } from '@mui/material';

export function WithAuth<P extends object>(WrappedComponent: React.ComponentType<P>) {
  return function WithAuth(props: P) {
    const { status } = useSession();
    const router = useRouter();

    useEffect(() => {
      if (status === 'loading') return; // Do nothing while loading

      if (status === 'unauthenticated') {
        router.push('/auth/signin');
      }
    }, [status, router]);

    if (status === 'loading') {
      return (
        <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
          <CircularProgress />
        </Box>
      );
    }

    if (status === 'authenticated') {
      return <WrappedComponent {...props} />;
    }

    return null; // Render nothing while redirecting
  };
}


// Filename: config/index.ts
// File: config/index.ts

import { config } from 'dotenv';

// Load environment variables from .env file
config();

const CONFIG = {
  database: {
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT || '5432', 10),
    name: process.env.DB_NAME,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
  },
  google: {
    clientId: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    clientEmail: process.env.GOOGLE_CLIENT_EMAIL,
    privateKey: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
  },
  nextAuth: {
    url: process.env.NEXTAUTH_URL,
    secret: process.env.NEXTAUTH_SECRET,
  },
  apiKeys: {
    dailyIndexing: process.env.DAILY_INDEXING_API_KEY,
  },
};

export default CONFIG;

// Filename: lib/ErrorContext.ts
// lib/ErrorContext.ts
import { createContext } from 'react';

interface ErrorContextType {
  setError: (error: string | null) => void;
}

export const ErrorContext = createContext<ErrorContextType>({
  setError: () => {},
});

// Filename: lib/authOptions.ts
import GoogleProvider from 'next-auth/providers/google';
import { getUserByEmail, createUser, updateUser } from '@/models';
import { fetchAndStoreWebsites } from '@/lib/googleSearchConsole';
import { AuthOptions } from 'next-auth';
import CONFIG from '@/config';

export const authOptions: AuthOptions = {
  providers: [
    GoogleProvider({
      clientId: CONFIG.google.clientId as string,
      clientSecret: CONFIG.google.clientSecret as string,
      authorization: {
        params: {
          scope: 'openid email profile',
        },
      },
    }),
  ],
  callbacks: {
    async signIn({ user, account }) {
      if (account?.provider === "google" && user.email) {
        try {
          const { user: dbUser } = await getUserByEmail(user.email);
          if (dbUser) {
            await updateUser(dbUser.id, {
              name: user.name,
              google_id: user.id,
            });
            user.id = dbUser.id.toString(); // Convert to string
          } else {
            const newUser = await createUser({
              name: user.name,
              email: user.email,
              google_id: user.id,
            });
            user.id = newUser.user.id.toString(); // Convert to string

            // Fetch and store websites for new users
            await fetchAndStoreWebsites(parseInt(user.id)); // Convert back to number for our internal function
          }
          return true;
        } catch (error) {
          console.error('Error saving user to database:', error);
          return false;
        }
      }
      return true;
    },
    async session({ session, token }) {
      if (session?.user && token.sub) {
        session.user.id = token.sub;
      }
      return session;
    },
    async jwt({ token, account, user }) {
      // Initial sign-in
      if (account && user) {
        token.userId = user.id;
      }
      return token;
    },
  },
  pages: {
    signIn: '/auth/signin',
  },
  session: {
    strategy: 'jwt',
  },
};


// Filename: lib/db.ts
import { Pool } from 'pg';
import CONFIG from '@/config';

const pool = new Pool({
  host: CONFIG.database.host,
  port: CONFIG.database.port,
  database: CONFIG.database.name,
  user: CONFIG.database.user,
  password: CONFIG.database.password,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

export default pool;

// Filename: lib/googleSearchConsole.ts
import { google } from 'googleapis';
import { JWT } from 'google-auth-library';
import { IndexingStatus } from '@/types';
import { getWebsitesByUserId, getWebsiteById, createWebsite, updateWebsite } from '@/models';
import CONFIG from '@/config';

const auth = new JWT({
  email: CONFIG.google.clientEmail,
  key: CONFIG.google.privateKey,
  scopes: ['https://www.googleapis.com/auth/webmasters.readonly', 'https://www.googleapis.com/auth/indexing'],
});

const searchconsole = google.searchconsole({ version: 'v1', auth });

async function rateLimitedFetch<T>(items: T[], fetchFn: (item: T) => Promise<any>, rateLimit: number): Promise<any[]> {
    const results = [];
    for (let i = 0; i < items.length; i += rateLimit) {
      const batch = items.slice(i, i + rateLimit);
      const batchResults = await Promise.all(batch.map(fetchFn));
      results.push(...batchResults);
      if (i + rateLimit < items.length) {
        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second between batches
      }
    }
    return results;
  }  

export async function fetchAndStoreWebsites(userId: number): Promise<void> {
    try {
      const sites = await searchconsole.sites.list();
      const { websites: existingWebsites } = await getWebsitesByUserId(userId);
  
      const updatedWebsites = new Set<string>();
  
      if (sites.data.siteEntry) {
        for (const site of sites.data.siteEntry) {
          const domain = site.siteUrl || '';
          const existingWebsite = existingWebsites.find(w => w.domain === domain);
  
          if (existingWebsite) {
            await updateWebsite(existingWebsite.id, {
              enabled: existingWebsite.enabled,
              auto_indexing_enabled: existingWebsite.auto_indexing_enabled,
            });
          } else if (domain) { 
            await createWebsite({
              user_id: userId,
              domain: domain,
              enabled: false,
              auto_indexing_enabled: false,
            });
          }
  
          if (domain) {
            updatedWebsites.add(domain);
          }
        }
      }
  
      for (const existingWebsite of existingWebsites) {
        if (!updatedWebsites.has(existingWebsite.domain)) {
          await updateWebsite(existingWebsite.id, { enabled: false });
        }
      }
    } catch (error) {
      console.error('Error fetching and storing websites:', error);
      throw error;
    }
}

export async function fetchBulkIndexingStatus(websiteId: number, urls: string[]): Promise<Array<{ url: string, lastIndexedDate: string | null, indexingStatus: IndexingStatus }>> {
  const { website } = await getWebsiteById(websiteId);
  if (!website) {
    throw new Error('Website not found');
  }

  const results = await rateLimitedFetch(urls, async (url) => {
    try {
      const response = await searchconsole.urlInspection.index.inspect({
        requestBody: {
          inspectionUrl: url,
          siteUrl: website.domain,
        },
      });

      const result = response.data.inspectionResult;
      return {
        url: url,
        lastIndexedDate: result?.indexStatusResult?.lastCrawlTime || null,
        indexingStatus: result?.indexStatusResult?.coverageState as IndexingStatus
      };
    } catch (error) {
      console.error(`Error inspecting URL ${url}:`, error);
      return {
        url: url,
        lastIndexedDate: null,
        indexingStatus: 'error' as IndexingStatus
      };
    }
  }, 100);

  /*
  for (const result of results) {
    await updatePageData(websiteId, result.url, result.indexingStatus, result.lastIndexedDate);
  }
  */

  return results;
}

export async function submitUrlForIndexing(domain: string, url: string): Promise<any> {
    const indexing = google.indexing({ version: 'v3', auth: auth });
  
    try {
      const response = await indexing.urlNotifications.publish({
        requestBody: {
          url: url,
          type: 'URL_UPDATED',
        },
      });
      console.log(`Submitted URL for indexing: ${url}`);
      return response;

    } catch (error) {
      console.error(`Error submitting URL for indexing: ${url}`, error);
      throw new Error('Failed to submit URL for indexing');
    }
  }
  

export async function getPageImpressionsAndClicks(websiteId: number, urls: string[]) {
  try {
    const { website } = await getWebsiteById(websiteId);
    if (!website) {
      throw new Error('Website not found');
    }

    const startDate = new Date();
    startDate.setDate(startDate.getDate() - 30); // Last 30 days
    const endDate = new Date();

    const response = await searchconsole.searchanalytics.query({
      siteUrl: website.domain,
      requestBody: {
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0],
        dimensions: ['page'],
        rowLimit: urls.length,
      },
    });

    const result: { [key: string]: { impressions: number, clicks: number } } = {};

    urls.forEach(url => {
      result[url] = { impressions: 0, clicks: 0 };
    });

    if (response.data.rows) {
      response.data.rows.forEach((row: any) => {
        const url = row.keys[0];
        if (urls.includes(url)) {
          result[url] = {
            impressions: row.impressions,
            clicks: row.clicks,
          };
        }
      });
    }
    return result;

  } catch (error) {
    console.error('Error fetching Search Console data:', error);
    throw new Error('Failed to fetch Search Console data');
  }
}

export async function verifyWebsiteOwnership(property: string): Promise<boolean> {
  try {
      const response = await searchconsole.sites.get({ siteUrl: property });
      // If the service account has access, the property exists, and the response returns successfully.
      if (response.data.siteUrl === property) {
        return true;
      }
      return false;

    } catch (error) {
      console.error(`Error verifying website ownership for ${property}:`, error);
      return false;
  }
}

// Filename: lib/jobQueue.ts
import { processSingleWebsite } from '@/lib/sitemapProcessor';
import { processWebsiteForScheduledJob } from '@/lib/scheduledSitemapProcessor';
import { getWebsiteById } from '@/models';

interface Job {
  websiteId: number;
  type: 'ui' | 'scheduled';
}

class JobQueue {
  private queue: Job[] = [];
  private isProcessing: boolean = false;

  async addJob(websiteId: number, type: 'ui' | 'scheduled'): Promise<void> {
    if (typeof websiteId !== 'number') {
      throw new Error('Invalid websiteId: must be a number');
    }
    this.queue.push({ websiteId, type });
    if (!this.isProcessing) {
      this.processNextJob();
    }
  }

  private async processNextJob(): Promise<void> {
    if (this.queue.length === 0) {
      this.isProcessing = false;
      return;
    }

    this.isProcessing = true;
    const job = this.queue.shift();

    if (job) {
      try {
        const { website } = await getWebsiteById(job.websiteId);
        if (website) {
          if (job.type === 'ui') {
            await processSingleWebsite(website);
          } else if (job.type === 'scheduled') {
            await processWebsiteForScheduledJob(website);
          }
        } else {
          console.error(`Website with id ${job.websiteId} not found`);
        }
      } catch (error) {
        console.error(`Error processing website ${job.websiteId}:`, error);
      }
    }

    setImmediate(() => this.processNextJob());
  }
}

const jobQueue = new JobQueue();

export default jobQueue;

// Filename: lib/scheduledSitemapProcessor.ts
import { Website, Page } from '@/types';
import { 
  addOrUpdatePagesFromSitemap, 
  getPagesByWebsiteId,
  removePages,
  createIndexingJob,
  updateIndexingJob,
  createIndexingJobDetail
} from '@/models';
import { fetchBulkIndexingStatus, submitUrlForIndexing } from './googleSearchConsole';
import { fetchUrl, extractSitemapUrls, parseSitemap, filterSitemaps, cleanDomain } from './sitemapProcessor';
import { promisify } from 'util';

const delay = promisify(setTimeout);
const indexed: string = 'Submitted and indexed';

export async function processWebsiteForScheduledJob(website: Website): Promise<void> {
  try {
    const job = await createIndexingJob({ website_id: website.id, status: 'in_progress', total_pages: 0 });

    const cleanedDomain = cleanDomain(website.domain);
    const robotsTxtUrl = `https://${cleanedDomain}/robots.txt`;
    const robotsTxtContent = await fetchUrl(robotsTxtUrl);
    const allSitemapUrls = extractSitemapUrls(robotsTxtContent);
    const filteredSitemapUrls = filterSitemaps(allSitemapUrls);

    // get all pages from sitemaps
    let allPages: Pick<Page, 'url'>[] = [];
    for (const sitemapUrl of filteredSitemapUrls) {
      const sitemapContent = await fetchUrl(sitemapUrl);
      const pages = await parseSitemap(sitemapContent);
      allPages = allPages.concat(pages);
    }

    // get websites pages from database
    const { pages: existingPages } = await getPagesByWebsiteId(website.id, true);
    const existingUrls = new Set(existingPages.map(page => page.url));

    // website pages from sitemaps
    const currentUrls = new Set(allPages.map(page => page.url));

    // get new, removed and unchanged urls
    const newUrls = allPages.filter(page => !existingUrls.has(page.url));
    const removedUrls = existingPages.filter(page => !currentUrls.has(page.url));
    const unchangedUrls = allPages.filter(page => existingUrls.has(page.url));

    // get indexing data before submitting non-indexed pages
    const urlsToCheck = [...newUrls, ...unchangedUrls].map(page => page.url);
    let indexedPages = await fetchBulkIndexingStatus(website.id, urlsToCheck);

    // Submit non-indexed pages
    for (const page of indexedPages) {
      if (page.indexingStatus !== indexed) {
        try {
          await submitUrlForIndexing(website.domain, page.url);
          await createIndexingJobDetail({
            indexing_job_id: job.job.id,
            page_id: existingPages.find(p => p.url === page.url)?.id || 0,
            status: 'Submitted'
          });
        } catch (error) {
          console.error(`Error submitting URL for indexing: ${page.url}`, error);
        }
      }
    }

    // Wait for Google to process submissions
    await delay(20000); // Wait for 20 seconds

    // Fetch updated indexing statuses
    indexedPages = await fetchBulkIndexingStatus(website.id, urlsToCheck);

    const pagesToUpdate = indexedPages.map(page => ({
      url: page.url,
      indexingStatus: page.indexingStatus,
      lastIndexedDate: page.lastIndexedDate
    }));

    // Update database with final indexing data
    await addOrUpdatePagesFromSitemap(website.id, pagesToUpdate);

    // remove pages in database because were removed in sitemap
    if (removedUrls.length > 0) {
      await removePages(website.id, removedUrls.map(page => page.id));
    }

    // update the the Indexing Job completion
    await updateIndexingJob(job.job.id, { 
      status: 'completed', 
      processed_pages: pagesToUpdate.length 
    });

  } catch (error) {
    console.error(`Error processing website ${website.domain}:`, error);
    throw error;
  }
}

// Filename: lib/sitemapProcessor.ts
import axios from 'axios';
import { parseString } from 'xml2js';
import { promisify } from 'util';
import { Website, Page, IndexingStatus } from '@/types';
import { 
  addOrUpdatePagesFromSitemap, 
  updateWebsiteRobotsScan, 
  getPagesByWebsiteId,
  removePages
} from '@/models';
import { fetchBulkIndexingStatus } from './googleSearchConsole';
import { ValidationError } from '@/utils/errors';

const parseXml = promisify(parseString);

export function cleanDomain(inputDomain: string): string {
  let cleanedDomain = inputDomain.replace(/^sc-domain:/, '');
  try {
    const url = new URL(cleanedDomain);
    cleanedDomain = url.hostname;
  } catch {
    // If it's not a valid URL, assume it's already just a domain
  }
  cleanedDomain = cleanedDomain.replace(/^www\./, '');
  return cleanedDomain;
}

// Function to process a single website, called as part of the background job
export async function processSingleWebsite(website: Website): Promise<void> {
  try {
    const cleanedDomain = cleanDomain(website.domain);
    const robotsTxtUrl = `https://${cleanedDomain}/robots.txt`;
    const robotsTxtContent = await fetchUrl(robotsTxtUrl);
    const allSitemapUrls = extractSitemapUrls(robotsTxtContent);
    const filteredSitemapUrls = filterSitemaps(allSitemapUrls);

    let totalPages = 0;
    for (const sitemapUrl of filteredSitemapUrls) {
      const pageCount = await processSitemap(website.id, sitemapUrl);
      totalPages += pageCount;
    }

    console.log(`Processed ${totalPages} pages for ${cleanedDomain}`);
    await updateWebsiteRobotsScan(website.id);
  } catch (error) {
    console.error(`Error processing website ${cleanDomain(website.domain)}:`, error);
  }
}

// Function to filter sitemaps based on their names
export function filterSitemaps(sitemapUrls: string[]): string[] {
  const includePatterns = [
    /post-sitemap/,
    /page-sitemap/,
    /product-sitemap/,
    /^sitemap[-_]?index/,
    /^sitemap[-_]?pages/,
    /^sitemap[-_]?posts/,
    /^sitemap[-_]?products/
  ];

  const excludePatterns = [
    /category-sitemap/,
    /tag-sitemap/,
    /author-sitemap/,
    /^sitemap[-_]?category/,
    /^sitemap[-_]?tag/,
    /^sitemap[-_]?author/,
    /^sitemap[-_]?archive/
  ];

  return sitemapUrls.filter(url => {
    const sitemapName = new URL(url).pathname.split('/').pop() || '';
    
    if (excludePatterns.some(pattern => pattern.test(sitemapName))) {
      return false;
    }

    return includePatterns.some(pattern => pattern.test(sitemapName)) || sitemapName === 'sitemap.xml';
  });
}

async function processSitemap(websiteId: number, sitemapUrl: string): Promise<number> {
  try {
    const sitemapContent = await fetchUrl(sitemapUrl);
    const pages = await parseSitemap(sitemapContent);
    
    const urls = new Set(pages.map(page => page.url));

    // Fetch existing pages from the database
    const existingPages = await getPagesByWebsiteId(websiteId, true);

    // Identify pages to remove (in database but not in sitemap)
    const pagesToRemove = existingPages.pages.filter(page => !urls.has(page.url));

    // Fetch the actual indexing status and last indexed date from Google Search Console
    const indexedPages = await fetchBulkIndexingStatus(websiteId, Array.from(urls));

    // Combine sitemap data with indexing data
    const formattedPages = pages.map(page => {
      const indexedPage = indexedPages.find(ip => ip.url === page.url);
      return {
        url: page.url,
        lastIndexedDate: indexedPage?.lastIndexedDate || null,
        indexingStatus: indexedPage?.indexingStatus || 'unknown' as IndexingStatus
      };
    });

    // Update or add pages
    await addOrUpdatePagesFromSitemap(websiteId, formattedPages);

    // Remove pages that are no longer in the sitemap
    if (pagesToRemove.length > 0) {
      await removePages(websiteId, pagesToRemove.map(page => page.id));
    }

    return pages.length;

  } catch (error) {
    console.error(`Error processing sitemap ${sitemapUrl}:`, error);
    return 0;
  }
}

// Function to parse the sitemap XML and extract URLs
export async function parseSitemap(sitemapContent: string): Promise<Pick<Page, 'url'>[]> {
  try {
    const result: any = await parseXml(sitemapContent);
    if (result.sitemapindex) {
      // Sitemap index file containing multiple sitemaps
      const sitemapUrls = result.sitemapindex.sitemap.map((sitemap: any) => sitemap.loc[0]);
      const filteredSitemapUrls = filterSitemaps(sitemapUrls);
      const allPages = await Promise.all(filteredSitemapUrls.map(fetchAndParseSitemap));
      return allPages.flat();
    } else if (result.urlset) {
      // Regular sitemap containing URLs
      return result.urlset.url.map((url: any) => ({ url: url.loc[0] }));
    } else {
      throw new ValidationError('Invalid sitemap format');
    }
  } catch (error) {
    console.error('Error parsing sitemap:', error);
    throw new ValidationError('Failed to parse sitemap');
  }
}

// Helper function to fetch and parse a sitemap from a given URL
export async function fetchAndParseSitemap(sitemapUrl: string): Promise<{ url: string }[]> {
  const sitemapContent = await fetchUrl(sitemapUrl);
  return parseSitemap(sitemapContent);
}

// Function to fetch URL content (robots.txt, sitemap.xml, etc.)
export async function fetchUrl(url: string): Promise<string> {
  try {
    const response = await axios.get(url);
    return response.data;
  } catch (error) {
    console.error(`Error fetching URL ${url}:`, error);
    throw new ValidationError(`Failed to fetch URL: ${url}`);
  }
}

// Function to extract sitemap URLs from robots.txt
export function extractSitemapUrls(robotsTxtContent: string): string[] {
  const lines = robotsTxtContent.split('\n');
  return lines
    .filter(line => line.toLowerCase().startsWith('sitemap:'))
    .map(line => line.split(': ')[1].trim());
}


// Filename: lib/theme.ts
// lib/theme.ts
import { createTheme, responsiveFontSizes } from '@mui/material/styles';
import { deepmerge } from '@mui/utils';

declare module '@mui/material/styles' {
  interface Palette {
    customBackground: Palette['primary'];
    customText: Palette['primary'];
  }
  interface PaletteOptions {
    customBackground?: PaletteOptions['primary'];
    customText?: PaletteOptions['primary'];
  }
}

// Create a base theme
const baseTheme = createTheme({
  palette: {
    primary: {
      main: '#0f766e',
      light: '#14b8a6',
      dark: '#0d5b54',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#0ea5e9',
      light: '#38bdf8',
      dark: '#0284c7',
      contrastText: '#ffffff',
    },
    error: {
      main: '#ef4444',
      light: '#f87171',
      dark: '#dc2626',
      contrastText: '#ffffff',
    },
    warning: {
      main: '#f59e0b',
      light: '#fbbf24',
      dark: '#d97706',
      contrastText: '#000000',
    },
    info: {
      main: '#3b82f6',
      light: '#60a5fa',
      dark: '#2563eb',
      contrastText: '#ffffff',
    },
    success: {
      main: '#10b981',
      light: '#34d399',
      dark: '#059669',
      contrastText: '#ffffff',
    },
    grey: {
      50: '#f9fafb',
      100: '#f3f4f6',
      200: '#e5e7eb',
      300: '#d1d5db',
      400: '#9ca3af',
      500: '#6b7280',
      600: '#4b5563',
      700: '#374151',
      800: '#1f2937',
      900: '#111827',
    },
    customBackground: {
      main: '#ffffff',
      light: '#f3f4f6',
      dark: '#e5e7eb',
    },
    customText: {
      main: '#111827',
      light: '#374151',
      dark: '#1f2937',
    },
    background: {
      default: '#f3f4f6',
      paper: '#ffffff',
    },
    text: {
      primary: '#111827',
      secondary: '#4b5563',
    },
  },
  typography: {
    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 700,
      lineHeight: 1.2,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 700,
      lineHeight: 1.2,
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    h6: {
      fontSize: '1rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    subtitle1: {
      fontSize: '1rem',
      fontWeight: 400,
      lineHeight: 1.5,
    },
    subtitle2: {
      fontSize: '0.875rem',
      fontWeight: 500,
      lineHeight: 1.57,
    },
    body1: {
      fontSize: '1rem',
      fontWeight: 400,
      lineHeight: 1.5,
    },
    body2: {
      fontSize: '0.875rem',
      fontWeight: 400,
      lineHeight: 1.43,
    },
    button: {
      fontSize: '0.875rem',
      fontWeight: 500,
      lineHeight: 1.75,
      textTransform: 'none',
    },
    caption: {
      fontSize: '0.75rem',
      fontWeight: 400,
      lineHeight: 1.66,
    },
    overline: {
      fontSize: '0.75rem',
      fontWeight: 600,
      lineHeight: 2.66,
      textTransform: 'uppercase',
    },
  },
  shape: {
    borderRadius: 8,
  },
  mixins: {
    toolbar: {
      minHeight: 64,
    },
  },
});

// Customize the base theme
const customTheme = deepmerge(baseTheme, {
  components: {
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: baseTheme.palette.background.paper,
          color: baseTheme.palette.text.primary,
          boxShadow: 'none',
          borderBottom: `1px solid ${baseTheme.palette.grey[200]}`,
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: '0.375rem',
          fontWeight: 600,
          boxShadow: 'none',
          '&:hover': {
            boxShadow: 'none',
          },
        },
        containedPrimary: {
          '&:hover': {
            backgroundColor: baseTheme.palette.primary.dark,
          },
        },
        containedSecondary: {
          '&:hover': {
            backgroundColor: baseTheme.palette.secondary.dark,
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: '0.5rem',
          boxShadow: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
        },
      },
    },
    MuiCardHeader: {
      styleOverrides: {
        root: {
          padding: baseTheme.spacing(3),
        },
      },
    },
    MuiCardContent: {
      styleOverrides: {
        root: {
          padding: baseTheme.spacing(3),
        },
      },
    },
    MuiCardActions: {
      styleOverrides: {
        root: {
          padding: baseTheme.spacing(3),
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: '0.375rem',
        },
      },
    },
    MuiDialog: {
      styleOverrides: {
        paper: {
          borderRadius: '0.5rem',
        },
      },
    },
    MuiDivider: {
      styleOverrides: {
        root: {
          borderColor: baseTheme.palette.grey[200],
        },
      },
    },
    MuiInputBase: {
      styleOverrides: {
        root: {
          borderRadius: '0.375rem',
        },
      },
    },
    MuiOutlinedInput: {
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-notchedOutline': {
            borderColor: baseTheme.palette.grey[300],
          },
          '&:hover .MuiOutlinedInput-notchedOutline': {
            borderColor: baseTheme.palette.grey[400],
          },
          '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
            borderColor: baseTheme.palette.primary.main,
          },
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: 'none',
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        root: {
          borderBottom: `1px solid ${baseTheme.palette.grey[200]}`,
        },
      },
    },
    MuiTableHead: {
      styleOverrides: {
        root: {
          backgroundColor: baseTheme.palette.grey[50],
          '.MuiTableCell-root': {
            color: baseTheme.palette.text.secondary,
            fontWeight: 600,
          },
        },
      },
    },
    MuiTooltip: {
      styleOverrides: {
        tooltip: {
          backgroundColor: baseTheme.palette.grey[800],
        },
      },
    },
  },
});

// Make the theme responsive
const theme = responsiveFontSizes(customTheme);

export default theme;

// Filename: lib/tokenManager.ts
import { JWT } from 'google-auth-library';
import { TokenError } from '@/utils/errors';
import CONFIG from '@/config';

let cachedClient: JWT | null = null;

export async function getServiceAccountToken(): Promise<string> {
  try {
    if (!cachedClient) {
      cachedClient = new JWT({
        email: CONFIG.google.clientEmail,
        key: CONFIG.google.privateKey,
        scopes: ['https://www.googleapis.com/auth/webmasters.readonly', 'https://www.googleapis.com/auth/indexing'],
      });
    }

    const token = await cachedClient.authorize();
    return token.access_token || '';
  } catch (error) {
    console.error('Error getting service account token:', error);
    throw new TokenError('Failed to obtain service account token');
  }
}

export async function revokeServiceAccountToken(): Promise<void> {
  if (cachedClient) {
    try {
      await cachedClient.revokeCredentials();
    } catch (error) {
      console.error('Error revoking service account token:', error);
    } finally {
      cachedClient = null;
    }
  }
}

// Filename: lib/useError.ts
// lib/useError.ts
import { useContext } from 'react';
import { ErrorContext } from './ErrorContext';

export function useError() {
  const { setError } = useContext(ErrorContext);
  return setError;
}

// Filename: models/index.ts
// File: models/index.ts

import pool from '@/lib/db';
import { User, Website, Page, IndexingJob, IndexingJobDetail, IndexingStatus, IndexingStatsData, EmailNotification } from '@/types';
import { DatabaseError } from '@/utils/errors';

// Helper function to handle database errors
function handleDatabaseError(error: any): never {
  console.error('Database error:', error);
  if (error.code === '23505') { // unique_violation
    throw new DatabaseError('Duplicate entry');
  } else if (error.code === '23503') { // foreign_key_violation
    throw new DatabaseError('Related resource not found');
  } else {
    throw new DatabaseError('Database error occurred');
  }
}

export async function getUserByEmail(email: string): Promise<{ user: User | null, statusCode: number }> {
  try {
    const query = 'SELECT * FROM users WHERE email = $1';
    const result = await pool.query(query, [email]);
    let user = result.rows[0] || null;
    if (user) {
      user.id = user.id.toString(); // Convert ID to string
    }
    return { user, statusCode: user ? 200 : 404 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createUser(user: Partial<User>): Promise<{ user: User, statusCode: number }> {
  try {
    const { name, email, google_id } = user;
    const query = 'INSERT INTO users (name, email, google_id) VALUES ($1, $2, $3) RETURNING *';
    const result = await pool.query(query, [name, email, google_id]);
    return { user: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updateUser(id: number, user: Partial<User>): Promise<{ user: User, statusCode: number }> {
  try {
    const { name, google_id } = user;
    const query = 'UPDATE users SET name = COALESCE($1, name), google_id = COALESCE($2, google_id), updated_at = CURRENT_TIMESTAMP WHERE id = $3 RETURNING *';
    const result = await pool.query(query, [name, google_id, id]);
    if (result.rowCount === 0) {
      throw new DatabaseError('User not found');
    }
    return { user: result.rows[0], statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function getWebsitesByUserId(userId: number): Promise<{ websites: Website[], statusCode: number }> {
  try {
    const query = 'SELECT * FROM websites WHERE user_id = $1';
    const result = await pool.query(query, [userId]);
    return { websites: result.rows, statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function getWebsiteById(id: number): Promise<{ website: Website | null, statusCode: number }> {
  try {
    const query = 'SELECT * FROM websites WHERE id = $1';
    const result = await pool.query(query, [id]);
    return { website: result.rows[0] || null, statusCode: result.rows[0] ? 200 : 404 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function getIndexingStatsByWebsiteId(id: number): Promise<{ indexingStats: IndexingStatsData | null, statusCode: number}> {
  try {
    const query = 'SELECT * FROM get_indexing_stats($1)';
    const result = await pool.query(query, [id]);
    return { indexingStats: result.rows[0] || null, statusCode: result.rows[0] ? 200 : 404 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function getWebsitesForIndexing(): Promise<{ websites: Website[], statusCode: number }> {
  try {
    const query = `
      SELECT * FROM websites 
      WHERE enabled = true 
      AND (last_robots_scan IS NULL OR last_robots_scan < NOW() - INTERVAL '21 hours')
    `;
    const result = await pool.query(query);
    return { websites: result.rows, statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createWebsite(website: Partial<Website>): Promise<{ website: Website, statusCode: number }> {
  try {
    const { user_id, domain, enabled, auto_indexing_enabled } = website;
    const query = 'INSERT INTO websites (user_id, domain, enabled, auto_indexing_enabled) VALUES ($1, $2, $3, $4) RETURNING *';
    const result = await pool.query(query, [user_id, domain, enabled, auto_indexing_enabled]);
    return { website: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updateWebsite(id: number, website: Partial<Website>): Promise<{ website: Website, statusCode: number }> {
  try {
    const { domain, enabled, auto_indexing_enabled } = website;
    const query = `
      UPDATE websites 
      SET domain = COALESCE($1, domain), 
          enabled = COALESCE($2, enabled),      
          auto_indexing_enabled = COALESCE($3, auto_indexing_enabled),
          updated_at = CURRENT_TIMESTAMP 
      WHERE id = $4 
      RETURNING *
    `;
    const result = await pool.query(query, [domain, enabled, auto_indexing_enabled, id]);
    if (result.rowCount === 0) {
      throw new DatabaseError('Website not found');
    }
    return { website: result.rows[0], statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updateWebsiteRobotsScan(id: number): Promise<{ statusCode: number }> {
  try {
    const query = 'SELECT update_website_robots_scan($1)';
    await pool.query(query, [id]);
    return { statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function getPagesByWebsiteId(
  websiteId: number, 
  all: boolean = false,
  page: number = 0, 
  pageSize: number = 25, 
  orderBy: string = 'url', 
  order: 'asc' | 'desc' = 'asc'
): Promise<{ pages: Page[], totalCount: number, statusCode: number }> {
  try {
    let query: string;
    let countQuery: string;
    let queryParams: any[];

    if (all) {
      query = 'SELECT * FROM pages WHERE website_id = $1';
      countQuery = 'SELECT COUNT(*) FROM pages WHERE website_id = $1';
      queryParams = [websiteId];
    } else {
      const offset = page * pageSize;
      query = `
        SELECT * FROM pages 
        WHERE website_id = $1 
        ORDER BY ${orderBy} ${order}
        LIMIT $2 OFFSET $3
      `;
      countQuery = 'SELECT COUNT(*) FROM pages WHERE website_id = $1';
      queryParams = [websiteId, pageSize, offset];
    }
    
    const [result, countResult] = await Promise.all([
      pool.query(query, queryParams),
      pool.query(countQuery, [websiteId])
    ]);

    return { 
      pages: result.rows, 
      totalCount: parseInt(countResult.rows[0].count), 
      statusCode: 200 
    };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function getPageById(id: number): Promise<{ page: Page | null, statusCode: number }> {
  try {
    const query = 'SELECT * FROM pages WHERE id = $1';
    const result = await pool.query(query, [id]);
    return { page: result.rows[0] || null, statusCode: result.rows[0] ? 200 : 404 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createPage(page: Partial<Page>): Promise<{ page: Page, statusCode: number }> {
  try {
    const { website_id, url } = page;
    const query = 'INSERT INTO pages (website_id, url) VALUES ($1, $2) RETURNING *';
    const result = await pool.query(query, [website_id, url]);
    return { page: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updatePageData(websiteId: number, url: string, indexingStatus: string, lastIndexed: Date | null): Promise<void> {
  try {
    const query = `
      UPDATE pages
      SET indexing_status = $1,
          last_indexed_date = $2,
          updated_at = CURRENT_TIMESTAMP
      WHERE website_id = $3 AND url = $4
    `;
    await pool.query(query, [indexingStatus, lastIndexed, websiteId, url]);
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function addOrUpdatePagesFromSitemap(websiteId: number, pages: { url: string, lastIndexedDate?: string | null, indexingStatus?: IndexingStatus }[]
): Promise<{ statusCode: number }> {
  try {
    const query = 'SELECT bulk_upsert_pages($1, $2)';
    await pool.query(query, [websiteId, JSON.stringify(pages)]);
    return { statusCode: 200 };

  } catch (error) {
    console.error('Error in addOrUpdatePagesFromSitemap:', error);
    throw error;
  }
}

export async function removePages(websiteId: number, pageIds: number[]): Promise<{ statusCode: number }> {
  try {
    const query = `
      DELETE FROM pages
      WHERE website_id = $1 AND id = ANY($2::int[])
    `;
    await pool.query(query, [websiteId, pageIds]);
    return { statusCode: 200 };
  } catch (error) {
    console.error('Error removing pages:', error);
    handleDatabaseError(error);
  }
}

export async function getPagesForIndexing(websiteId: number, limit: number): Promise<{ pages: Page[], statusCode: number }> {
  try {
    const query = 'SELECT * FROM get_pages_for_indexing($1, $2)';
    const result = await pool.query(query, [websiteId, limit]);
    return { pages: result.rows, statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createIndexingJob(job: Partial<IndexingJob>): Promise<{ job: IndexingJob, statusCode: number }> {
  try {
    const { website_id, status, total_pages } = job;
    const query = 'INSERT INTO indexing_jobs (website_id, status, started_at, total_pages, processed_pages) VALUES ($1, $2, CURRENT_TIMESTAMP, $3, 0) RETURNING *';
    const result = await pool.query(query, [website_id, status, total_pages]);
    return { job: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updateIndexingJob(id: number, job: Partial<IndexingJob>): Promise<{ job: IndexingJob, statusCode: number }> {
  try {
    const { status, processed_pages } = job;
    const query = 'UPDATE indexing_jobs SET status = COALESCE($1, status), processed_pages = COALESCE($2, processed_pages), completed_at = CASE WHEN $1 = \'completed\' THEN CURRENT_TIMESTAMP ELSE completed_at END, updated_at = CURRENT_TIMESTAMP WHERE id = $3 RETURNING *';
    const result = await pool.query(query, [status, processed_pages, id]);
    if (result.rowCount === 0) {
      throw new DatabaseError('Indexing job not found');
    }
    return { job: result.rows[0], statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createIndexingJobDetail(detail: Partial<IndexingJobDetail>): Promise<{ detail: IndexingJobDetail, statusCode: number }> {
  try {
    const { indexing_job_id, page_id, status } = detail;
    const query = 'INSERT INTO indexing_job_details (indexing_job_id, page_id, status, submitted_at) VALUES ($1, $2, $3, CURRENT_TIMESTAMP) RETURNING *';
    const result = await pool.query(query, [indexing_job_id, page_id, status]);
    return { detail: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updateIndexingJobDetail(id: number, detail: Partial<IndexingJobDetail>): Promise<{ detail: IndexingJobDetail, statusCode: number }> {
  try {
    const { status, response } = detail;
    const query = 'SELECT * FROM update_indexing_job_detail_status($1, $2, $3)';
    const result = await pool.query(query, [id, status, response]);
    if (result.rowCount === 0) {
      throw new DatabaseError('Indexing job detail not found');
    }
    return { detail: result.rows[0], statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createEmailNotification(notification: Partial<EmailNotification>): Promise<{ notification: EmailNotification, statusCode: number }> {
  try {
    const { user_id, website_id, type, content } = notification;
    const query = 'SELECT * FROM create_email_notification($1, $2, $3, $4)';
    const result = await pool.query(query, [user_id, website_id, type, content]);
    return { notification: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}


// Filename: next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.


// Filename: next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: '/api/:path*',
      },
    ]
  },
}

module.exports = nextConfig

// Filename: types/index.ts
// File: types/index.ts

export interface User {
  id: number;
  email: string;
  name: string | null;
  google_id: string | null;
  access_token: string | null;
  refresh_token: string | null;
  expires_at: Date | null;
  created_at: Date;
  updated_at: Date;
}
  
export interface Website {
  id: number;
  user_id: number;
  domain: string;
  enabled: boolean;
  auto_indexing_enabled: boolean;
  is_owner: boolean | null;
  last_robots_scan: Date | null;
  created_at: Date;
  updated_at: Date;
}

export interface Page {
  id: number;
  website_id: number;
  url: string;
  last_sitemap_check: Date | null;
  last_indexed_date: Date | null;
  indexing_status: IndexingStatus;
  created_at: Date;
  updated_at: Date;
}
  
export type IndexingStatus = 
  'Indexed' | 
  'Submitted' |
  'Submitted and indexed' | 
  'Submitted not indexed' | 
  'Discovered not indexed' | 
  'Crawled not indexed' | 
  'Excluded noindex' | 
  'Blocked robots' | 
  'Duplicate without canonical';

export interface IndexingJob {
  id: number;
  website_id: number;
  status: JobStatus;
  started_at: Date | null;
  completed_at: Date | null;
  total_pages: number;
  processed_pages: number;
  created_at: Date;
  updated_at: Date;
}

export type JobStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

export interface IndexingJobDetail {
  id: number;
  indexing_job_id: number;
  page_id: number;
  status: IndexingStatus;
  submitted_at: Date | null;
  response: string | null;
  created_at: Date;
  updated_at: Date;
}

export interface EmailNotification {
  id: number;
  user_id: number;
  website_id: number;
  type: NotificationType;
  content: string;
  sent_at: Date | null;
  created_at: Date;
}

export type NotificationType = 'indexing_complete' | 'indexing_failed' | 'new_page_found';

export interface IndexingStatsData {
  total_pages: number;
  indexed_pages: number;
  not_indexed_pages: number;
}

// Filename: types/next-auth.d.ts
import NextAuth from "next-auth"

declare module "next-auth" {
  interface Session {
    user: {
      id: string
      name?: string | null
      email?: string | null
      image?: string | null
    }
  }
}

// Filename: utils/apiUtils.ts
// File: utils/apiUtils.ts
import { NextRequest, NextResponse } from 'next/server';
import { AppError, DatabaseError, ValidationError, AuthenticationError, AuthorizationError, NotFoundError } from './errors';

export async function handleApiError(error: unknown): Promise<NextResponse> {
  console.error('API Error:', error);

  let appError: AppError;

  if (error instanceof AppError) {
    appError = error;
  } else if (error instanceof Error) {
    // Convert known error types to specific AppError subclasses
    if (error.name === 'DatabaseError') {
      appError = new DatabaseError(error.message);
    } else if (error.name === 'ValidationError') {
      appError = new ValidationError(error.message);
    } else if (error.name === 'AuthenticationError') {
      appError = new AuthenticationError(error.message);
    } else if (error.name === 'AuthorizationError') {
      appError = new AuthorizationError(error.message);
    } else if (error.name === 'NotFoundError') {
      appError = new NotFoundError(error.message);
    } else {
      appError = new AppError(error.message, 500, 'INTERNAL_SERVER_ERROR');
    }
  } else {
    appError = new AppError('An unexpected error occurred', 500, 'INTERNAL_SERVER_ERROR');
  }

  const errorResponse = {
    status: 'error',
    message: appError.message,
    errorCode: appError.errorCode,
  };

  return NextResponse.json(errorResponse, { status: appError.statusCode });
}

export function withErrorHandling(handler: (req: NextRequest) => Promise<NextResponse>) {
  return async (req: NextRequest) => {
    try {
      return await handler(req);
    } catch (error) {
      return handleApiError(error);
    }
  };
}

// Filename: utils/errors.ts
// File: utils/errors.ts

export interface ErrorResponse {
  status: 'error';
  message: string;
  statusCode: number;
  errorCode?: string;
}

export class AppError extends Error {
  statusCode: number;
  errorCode: string;

  constructor(message: string, statusCode: number, errorCode: string) {
    super(message);
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class DatabaseError extends AppError {
  constructor(message = 'A database error occurred') {
    super(message, 500, 'DATABASE_ERROR');
  }
}

export class ValidationError extends AppError {
  constructor(message = 'Invalid input data') {
    super(message, 400, 'VALIDATION_ERROR');
  }
}

export class AuthenticationError extends AppError {
  constructor(message = 'Authentication failed') {
    super(message, 401, 'AUTHENTICATION_ERROR');
  }
}

export class AuthorizationError extends AppError {
  constructor(message = 'You do not have permission to perform this action') {
    super(message, 403, 'AUTHORIZATION_ERROR');
  }
}

export class NotFoundError extends AppError {
  constructor(message = 'The requested resource was not found') {
    super(message, 404, 'NOT_FOUND_ERROR');
  }
}

export class TokenError extends AppError {
  constructor(message = 'Token error occurred') {
    super(message, 401, 'TOKEN_ERROR');
  }
}

export class AccessRevokedError extends AppError {
  constructor(message = 'Access has been revoked') {
    super(message, 403, 'ACCESS_REVOKED_ERROR');
  }
}

export function createErrorResponse(error: AppError): ErrorResponse {
  return {
    status: 'error',
    message: error.message,
    statusCode: error.statusCode,
    errorCode: error.errorCode
  };
}

export function getClientErrorMessage(error: AppError): string {
  switch (error.errorCode) {
    case 'DATABASE_ERROR':
      return 'We\'re experiencing technical difficulties. Please try again later.';
    case 'VALIDATION_ERROR':
      return 'Please check your input and try again.';
    case 'AUTHENTICATION_ERROR':
      return 'Please log in to continue.';
    case 'AUTHORIZATION_ERROR':
      return 'You don\'t have permission to perform this action.';
    case 'NOT_FOUND_ERROR':
      return 'The requested information could not be found.';
    case 'TOKEN_ERROR':
      return 'There was an issue with your authentication. Please try logging in again.';
    case 'ACCESS_REVOKED_ERROR':
      return 'Your access to the required services has been revoked. Please re-authorize the application.';
    default:
      return 'An unexpected error occurred. Please try again later.';
  }
}

// Filename: utils/runMigrations.ts
import fs from 'fs';
import path from 'path';
import pool from '@/lib/db';

export async function runMigrations() {
  const migrationsDir = path.join(process.cwd(), 'migrations');
  const migrationFiles = fs.readdirSync(migrationsDir).sort();

  for (const file of migrationFiles) {
    const migration = fs.readFileSync(path.join(migrationsDir, file), 'utf-8');
    try {
      await pool.query(migration);
      console.log(`Ran migration: ${file}`);
    } catch (error) {
      console.error(`Error running migration ${file}:`, error);
      throw error;
    }
  }
}
