
// Filename: app/api/auth/[...nextauth]/route.ts
import NextAuth, { AuthOptions } from 'next-auth';
import GoogleProvider from 'next-auth/providers/google';
import { getUserByEmail, createUser, updateUser } from '@/models';
import { fetchAndStoreWebsites } from '@/lib/googleSearchConsole';
import CONFIG from '@/config';

export const authOptions: AuthOptions = {
  providers: [
    GoogleProvider({
      clientId: CONFIG.google.clientId as string,
      clientSecret: CONFIG.google.clientSecret as string,
      authorization: {
        params: {
          scope: 'openid email profile https://www.googleapis.com/auth/webmasters.readonly https://www.googleapis.com/auth/analytics.readonly https://www.googleapis.com/auth/indexing',
          access_type: 'offline',
          prompt: 'consent',
        }
      }
    }),
  ],
  callbacks: {
    async signIn({ user, account }) {
      if (account?.provider === "google" && user.email) {
        try {
          const expiresAt = account.expires_at 
            ? new Date(account.expires_at * 1000).toISOString()
            : new Date(Date.now() + 3600 * 1000).toISOString(); // Default to 1 hour from now if expires_at is not provided

          const { user: dbUser } = await getUserByEmail(user.email);
          if (dbUser) {
            await updateUser(dbUser.id, {
              name: user.name,
              google_id: user.id,
              access_token: account.access_token,
              refresh_token: account.refresh_token,
              expires_at: expiresAt
            });
            user.id = dbUser.id;
          } else {
            const newUser = await createUser({
              name: user.name,
              email: user.email,
              google_id: user.id,
              access_token: account.access_token,
              refresh_token: account.refresh_token,
              expires_at: expiresAt
            });
            user.id = newUser.user.id;

            // Fetch and store websites for new users
            await fetchAndStoreWebsites(user.id, account.access_token);
          }
          return true;

        } catch (error) {
          console.error('Error saving user to database:', error);
          return false;
        }
      }
      return true;
    },
    async session({ session, token }) {
      if (session?.user && token.sub) {
        session.user.id = token.sub;
      }
      return session;
    },
    async jwt({ token, account, user }) {
      // Initial sign-in
      if (account && user) {
        token.userId = user.id;
        token.accessToken = account.access_token;
        token.refreshToken = account.refresh_token;
        token.accessTokenExpires = account.expires_at * 1000; // Convert to milliseconds
      }

      // Return the previous token if the access token has not expired yet
      if (Date.now() < token.accessTokenExpires) {
        return token;
      }

      // Access token has expired, refresh it using the refresh token
      console.log('Access token has expired, attempting to refresh...');
      return await refreshAccessToken(token);
    },
    async session({ session, token }) {
      session.user.id = token.userId;
      session.accessToken = token.accessToken;
      session.error = token.error;
      return session;
    },
  },
  pages: {
    signIn: '/auth/signin',
  },
  session: {
    strategy: 'jwt',
  },
};

const handler = NextAuth(authOptions);
export { handler as GET, handler as POST };

// Filename: app/api/websites/[websiteId]/analytics/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getWebsiteById } from '@/models';
import { getPageImpressionsAndClicks } from '@/lib/googleSearchConsole';
import { getValidAccessToken } from '@/lib/tokenManager';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError, ValidationError } from '@/utils/errors';

export const GET = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.nextUrl.pathname.split('/')[3]);
  const urls = request.nextUrl.searchParams.get('urls')?.split(',') || [];

  if (isNaN(websiteId)) {
    throw new ValidationError('Invalid website ID');
  }

  const { website } = await getWebsiteById(websiteId);

  if (!website || website.user_id !== parseInt(session.user.id)) {
    throw new NotFoundError('Website not found');
  }

  try {
    const accessToken = await getValidAccessToken(website.user_id);
    const analyticsData = await getPageImpressionsAndClicks(websiteId, urls, accessToken);
    return NextResponse.json({ 
      data: analyticsData, 
      message: Object.keys(analyticsData).length === 0 ? 'No data returned from Google Search Console' : 'Data retrieved successfully' 
    });
  } catch (error) {
    console.error('Error in analytics API route:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
});

// Filename: app/api/websites/[websiteId]/indexing-stats/route.ts
// Filename: /app/api/websites/[websiteId]/indexing-stats/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getIndexingStatsByWebsiteId } from '@/models';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError } from '@/utils/errors';

export const GET = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
      throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.nextUrl.pathname.split('/')[3]);

  if (isNaN(websiteId)) {
    throw new NotFoundError('Invalid website ID');
  }

  const indexingStats = await getIndexingStatsByWebsiteId(websiteId);
  return NextResponse.json({ indexingStats });
});


// Filename: app/api/websites/[websiteId]/pages/[pageId]/submit-for-indexing/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getWebsiteById, getPageById, updatePageData } from '@/models';
import { submitUrlForIndexing } from '@/lib/googleSearchConsole';
import { getValidAccessToken } from '@/lib/tokenManager';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError, ValidationError } from '@/utils/errors';

export const POST = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.nextUrl.pathname.split('/')[3]);
  const pageId = parseInt(request.nextUrl.pathname.split('/')[5]);

  if (isNaN(websiteId) || isNaN(pageId)) {
    throw new ValidationError('Invalid website ID or page ID');
  }

  const { website } = await getWebsiteById(websiteId);
  const { page } = await getPageById(pageId);

  if (!website || !page || website.id !== page.website_id) {
    throw new NotFoundError('Website or page not found');
  }

  if (website.user_id !== parseInt(session.user.id)) {
    throw new AuthenticationError('You do not have permission to submit this page');
  }

  // Check if 24 hours have passed since the last submission
  const lastSubmissionDate = new Date(page.last_indexed_date);
  const currentDate = new Date();
  const hoursSinceLastSubmission = (currentDate.getTime() - lastSubmissionDate.getTime()) / (1000 * 60 * 60);

  if (hoursSinceLastSubmission < 24) {
    throw new ValidationError('You can only submit a page for indexing once every 24 hours');
  }

  const accessToken = await getValidAccessToken(parseInt(session.user.id));
  
  // Submit the URL for indexing
  await submitUrlForIndexing(website.domain, page.url, accessToken);

  // Update the page's last indexed date
  await updatePageData(websiteId, page.url, 'pending', new Date());

  return NextResponse.json({ message: 'Page submitted for indexing successfully' });
});

// Filename: app/api/websites/[websiteId]/pages/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getPagesByWebsiteId, getWebsiteById } from '@/models';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError } from '@/utils/errors';

export const GET = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.nextUrl.pathname.split('/')[3]);
  const searchParams = request.nextUrl.searchParams;
  const all = searchParams.get('all') === 'true';
  const page = parseInt(searchParams.get('page') || '0');
  const pageSize = parseInt(searchParams.get('pageSize') || '25');
  const orderBy = searchParams.get('orderBy') || 'url';
  const order = searchParams.get('order') || 'asc';

  if (isNaN(websiteId)) {
    throw new NotFoundError('Invalid website ID');
  }

  const { website } = await getWebsiteById(websiteId);

  if (!website || website.user_id !== parseInt(session.user.id)) {
    throw new NotFoundError('Website not found');
  }

  const { pages, totalCount } = await getPagesByWebsiteId(websiteId, all, page, pageSize, orderBy, order);

  return NextResponse.json({ pages, totalCount });
});

// Filename: app/api/websites/[websiteId]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getWebsiteById } from '@/models';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError } from '@/utils/errors';

export const GET = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.nextUrl.pathname.split('/')[3]);

  if (isNaN(websiteId)) {
    throw new NotFoundError('Invalid website ID');
  }

  const { website } = await getWebsiteById(websiteId);

  if (!website || website.user_id !== parseInt(session.user.id)) {
    throw new NotFoundError('Website not found');
  }

  return NextResponse.json(website);
});

// Filename: app/api/websites/[websiteId]/toggle-indexing/route.ts
// File: app/api/websites/[websiteId]/toggle-indexing/route.ts

import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getWebsiteById, updateWebsite, startIndexingJob } from '@/models';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError, NotFoundError, ValidationError } from '@/utils/errors';
import jobQueue from '@/lib/jobQueue';

export const POST = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.url.split('/').slice(-2)[0]);

  if (isNaN(websiteId)) {
    throw new ValidationError('Invalid website ID');
  }

  const { website } = await getWebsiteById(websiteId);
  if (!website) {
    throw new NotFoundError('Website not found');
  }

  if (website.user_id !== parseInt(session.user.id)) {
    throw new AuthenticationError('You do not have permission to modify this website');
  }

  const body = await request.json();
  const { enabled } = body;

  if (typeof enabled !== 'boolean') {
    throw new ValidationError('Invalid input: enabled must be a boolean');
  }

  const shouldRunJob = enabled && (
    !website.last_robots_scan || 
    new Date(website.last_robots_scan).getTime() < Date.now() - 24 * 60 * 60 * 1000
  );

  const { website: updatedWebsite } = await updateWebsite(websiteId, { indexing_enabled: enabled });

  let message = '';
  if (enabled) {
    message = 'Auto-indexing enabled.';
    if (shouldRunJob) {
      try {
        await jobQueue.addJob(websiteId, 'ui');
        message = 'Auto-indexing enabled. Fetching data from Google Search Console...';
      } catch (error) {
        console.error(`Failed to start indexing job for website ${websiteId}:`, error);
      }
    }
  } else {  
    message = 'Auto-indexing disabled.';
  }

  return NextResponse.json({ 
    website: updatedWebsite, 
    message,
    initialScanTime: website.last_robots_scan?.toISOString()
  });
});

export const GET = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const websiteId = parseInt(request.url.split('/').slice(-2)[0]);
  const initialScanTime = request.nextUrl.searchParams.get('initialScanTime');

  if (isNaN(websiteId) || !initialScanTime) {
    throw new ValidationError('Invalid website ID or initial scan time');
  }

  const { website } = await getWebsiteById(websiteId);
  
  if (!website || website.user_id !== parseInt(session.user.id)) {
    throw new NotFoundError('Website not found');
  }

  const isCompleted = website.last_robots_scan && new Date(website.last_robots_scan) > new Date(initialScanTime);

  return NextResponse.json({ 
    isCompleted,
    lastScanTime: website.last_robots_scan?.toISOString()
  });
});

// Filename: app/api/websites/daily-indexing/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getWebsitesForIndexing } from '@/models';
import { processWebsiteForScheduledJob } from '@/lib/scheduledSitemapProcessor';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthorizationError } from '@/utils/errors';
import CONFIG from '@/config';

export const POST = withErrorHandling(async (request: NextRequest) => {
  // Check for a secret token to ensure this route is only called by authorized systems
  if (request.headers.get('x-api-key') !== CONFIG.apiKeys.dailyIndexing) {
    throw new AuthorizationError('Invalid API key');
  }

  console.log('Starting daily indexing job');
  
  const { websites } = await getWebsitesForIndexing();

  console.log(`Found ${websites.length} websites to process`);

  for (const website of websites) {
    try {
      console.log(`Processing website: ${website.domain}`);
      await processWebsiteForScheduledJob(website);
      console.log(`Finished processing website: ${website.domain}`);

    } catch (error) {
      console.error(`Error processing website ${website.domain}:`, error);
    }
  }     

  console.log('Daily indexing job completed');

  return NextResponse.json({ message: 'Daily indexing job completed successfully' });
});

// Filename: app/api/websites/refresh/route.ts
// File: app/api/websites/refresh/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { fetchAndStoreWebsites } from '@/lib/googleSearchConsole';
import { getValidAccessToken } from '@/lib/tokenManager';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError } from '@/utils/errors';

export const POST = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user?.id) {
    throw new AuthenticationError('Unauthorized');
  }

  const userId = parseInt(session.user.id);
  const accessToken = await getValidAccessToken(userId);

  await fetchAndStoreWebsites(userId, accessToken);

  return NextResponse.json({ message: 'Websites refreshed successfully' });
});

// Filename: app/api/websites/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from "next-auth/next";
import { authOptions } from "@/app/api/auth/[...nextauth]/route";
import { getWebsitesByUserId } from '@/models';
import { withErrorHandling } from '@/utils/apiUtils';
import { AuthenticationError } from '@/utils/errors';

export const GET = withErrorHandling(async (request: NextRequest) => {
  const session = await getServerSession(authOptions);

  if (!session || !session.user) {
    throw new AuthenticationError('Unauthorized');
  }

  const userId = parseInt(session.user.id);
  const { websites } = await getWebsitesByUserId(userId);

  return NextResponse.json(websites || []);
});

// Filename: app/auth/signin/page.tsx
'use client';

import { Box, Typography, Button, useMediaQuery, Theme } from '@mui/material';
import Image from "next/image";
import { signIn } from 'next-auth/react';
import { Google as GoogleIcon } from '@mui/icons-material';
import { useRouter } from 'next/navigation';

export default function LoginPage() {
  const router = useRouter();
  const isMobile = useMediaQuery((theme: Theme) => theme.breakpoints.down('sm'));

  return (
    <Box sx={{ 
      display: 'flex', 
      flexDirection: isMobile ? 'column' : 'row',
      height: '100vh',
    }}>
      {/* Left side with image */}
      <Box sx={{ 
        flex: isMobile ? 'none' : 1, 
        position: 'relative',
        height: isMobile ? '30vh' : '100vh',
      }}>
        <Image
          src="/images/background.webp"
          alt="Website Indexer"
          priority
          layout="fill"
          objectFit="cover"
        />
      </Box>

      {/* Right side with login form */}
      <Box sx={{ 
        flex: isMobile ? 'none' : 1, 
        display: 'flex', 
        flexDirection: 'column', 
        justifyContent: 'center', 
        alignItems: 'center', 
        p: 4,
        height: isMobile ? '70vh' : '100vh',
      }}>
        <Typography variant="h4" component="h1" gutterBottom align="center">
          Website Indexer
        </Typography>
        <Typography variant="h6" component="h2" gutterBottom align="center">
          Inicia sesión o regístrate
        </Typography>

        <Box sx={{ mt: 4, width: '100%', maxWidth: 300 }}>
          <Button
            fullWidth
            variant="contained"
            color="primary"
            startIcon={<GoogleIcon />}
            onClick={() => signIn('google', { callbackUrl: '/dashboard' })}
            sx={{ mb: 2 }}
          >
            Continúa con Google
          </Button>

          <Typography variant="body2" align="center" sx={{ mt: 2 }}>
            Al continuar, aceptas nuestros{' '}
            <a href="/terms" style={{ color: 'blue' }}>Términos de uso</a> y nuestra{' '}
            <a href="/privacy" style={{ color: 'blue' }}>Política de privacidad</a>
          </Typography>
        </Box>
      </Box>
    </Box>
  );
}

// Filename: app/dashboard/page..tsx
'use client';

import React, { useState, useEffect } from 'react';
import Link from 'next/link';
import { 
  Container, 
  Typography, 
  Box, 
  CircularProgress, 
  Snackbar,
  Alert,
  Table, 
  TableBody, 
  TableCell, 
  TableContainer, 
  TableHead, 
  TableRow, 
  Paper, 
  TablePagination, 
  TableSortLabel,
  Button,
  Switch
} from '@mui/material';
import { Refresh as RefreshIcon } from '@mui/icons-material';
import MuiAlert, { AlertProps } from '@mui/material/Alert';
import { withAuth } from '@/components/withAuth';
import { Website } from '@/types';
import { useError } from '@/lib/useError';


const Dashboard: React.FC = () => {
  const [websites, setWebsites] = useState<Website[] | null>(null);
  const [loading, setLoading] = useState(true);
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10);
  const [orderBy, setOrderBy] = useState<keyof Website>('domain');
  const [order, setOrder] = useState<'asc' | 'desc'>('asc');
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' }>({
    open: false,
    message: '',
    severity: 'success',
  });
  const setError = useError();

  const Alert = React.forwardRef<HTMLDivElement, AlertProps>(function Alert(
    props,
    ref,
  ) {
    return <MuiAlert elevation={6} ref={ref} variant="filled" {...props} />;
  });
  

  useEffect(() => {
    fetchWebsites();
  }, []);

  const fetchWebsites = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/websites');
      if (!response.ok) {
        throw new Error('Failed to fetch websites');
      }
      const data = await response.json();
      setWebsites(data);
    } catch (error) {
      console.error('Error fetching websites:', error);
      setError('Failed to load websites. Please try again later.');
    } finally {
      setLoading(false);
    }
  };

  const handleToggleIndexing = async (websiteId: number, currentStatus: boolean) => {
    try {
      const response = await fetch(`/api/websites/${websiteId}/toggle-indexing`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ enabled: !currentStatus }),
      });
      if (!response.ok) {
        throw new Error('Failed to toggle indexing');
      }
      const data = await response.json();
      setWebsites(prevWebsites => 
        prevWebsites?.map(website => 
          website.id === websiteId ? { ...website, indexing_enabled: !currentStatus } : website
        ) || null
      );
      setSnackbar({
        open: true,
        message: data.message,
        severity: 'success',
      });
    } catch (error) {
      console.error('Error toggling indexing:', error);
      setError('Failed to update indexing status. Please try again later.');
      setSnackbar({
        open: true,
        message: 'Failed to update indexing status',
        severity: 'error',
      });
    }
  };

  const handleRefresh = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/websites/refresh', { method: 'POST' });
      if (!response.ok) {
        throw new Error('Failed to refresh websites');
      }
      await fetchWebsites();
      setSnackbar({
        open: true,
        message: 'Websites refreshed successfully',
        severity: 'success',
      });
    } catch (error) {
      console.error('Error refreshing websites:', error);
      setError('Failed to refresh websites. Please try again later.');
      setSnackbar({
        open: true,
        message: 'Failed to refresh websites',
        severity: 'error',
      });
    } finally {
      setLoading(false);
    }
  };

  const handleChangePage = (event: unknown, newPage: number) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event: React.ChangeEvent<HTMLInputElement>) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const handleRequestSort = (property: keyof Website) => {
    const isAsc = orderBy === property && order === 'asc';
    setOrder(isAsc ? 'desc' : 'asc');
    setOrderBy(property);
  };

  const extractDomain = (input: string): string => {
    if (!input) return 'Unknown Domain';
    let domain = input.replace(/^sc-domain:/, '');
    domain = domain.replace(/^(https?:\/\/)?(www\.)?/, '');
    domain = domain.split('/')[0].split('?')[0];
    return domain;
  };

  const formatLastScanned = (date: Date | null): string => {
    if (!date) return 'Never';
    return new Date(date).toLocaleString();
  };

  const sortedWebsites = websites?.slice().sort((a, b) => {
    let valueA = a[orderBy];
    let valueB = b[orderBy];
    
    if (orderBy === 'domain') {
      valueA = extractDomain(valueA as string);
      valueB = extractDomain(valueB as string);
    } else if (orderBy === 'last_robots_scan') {
      valueA = valueA ? new Date(valueA as Date).getTime() : 0;
      valueB = valueB ? new Date(valueB as Date).getTime() : 0;
    }
    
    if (valueA < valueB) {
      return order === 'asc' ? -1 : 1;
    }
    if (valueA > valueB) {
      return order === 'asc' ? 1 : -1;
    }
    return 0;
  });

  const paginatedWebsites = sortedWebsites?.slice(page * rowsPerPage, page * rowsPerPage + rowsPerPage);

  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Container sx={{ mt: 4 }}>
      <Box display="flex" justifyContent="space-between" alignItems="center" mb={2}>
        <Typography variant="h4" component="h1">
          Dashboard
        </Typography>
        <Button
          startIcon={<RefreshIcon />}
          onClick={handleRefresh}
          variant="outlined"
        >
          Refresh from Google Search Console
        </Button>
      </Box>
      {websites && (
        <TableContainer component={Paper}>
          <Table>
            <TableHead>
              <TableRow>
                <TableCell>
                  <TableSortLabel
                    active={orderBy === 'domain'}
                    direction={orderBy === 'domain' ? order : 'asc'}
                    onClick={() => handleRequestSort('domain')}
                  >
                    Website
                  </TableSortLabel>
                </TableCell>
                <TableCell>
                  <TableSortLabel
                    active={orderBy === 'last_robots_scan'}
                    direction={orderBy === 'last_robots_scan' ? order : 'asc'}
                    onClick={() => handleRequestSort('last_robots_scan')}
                  >
                    Last Scanned
                  </TableSortLabel>
                </TableCell>
                <TableCell>
                  <TableSortLabel
                    active={orderBy === 'indexing_enabled'}
                    direction={orderBy === 'indexing_enabled' ? order : 'asc'}
                    onClick={() => handleRequestSort('indexing_enabled')}
                  >
                    Auto-Indexing
                  </TableSortLabel>
                </TableCell>
              </TableRow>
            </TableHead>
            <TableBody>
              {paginatedWebsites?.map((website) => (
                <TableRow key={website.id}>
                  <TableCell>
                    {website.indexing_enabled ? (
                      <Link href={`/website/${website.id}`} passHref>
                        <Typography 
                          component="a" 
                          sx={{ 
                            color: 'primary.main', 
                            textDecoration: 'none',
                            '&:hover': {
                              textDecoration: 'underline',
                            },
                          }}
                        >
                          {extractDomain(website.domain)}
                        </Typography>
                      </Link>
                    ) : (
                      extractDomain(website.domain)
                    )}
                  </TableCell>
                  <TableCell>{formatLastScanned(website.last_robots_scan)}</TableCell>
                  <TableCell>
                    <Switch
                      checked={website.indexing_enabled}
                      onChange={() => handleToggleIndexing(website.id, website.indexing_enabled)}
                    />
                  </TableCell>
                </TableRow>
              ))}
            </TableBody>
          </Table>
        </TableContainer>
      )}
      <TablePagination
        rowsPerPageOptions={[10, 25, 50]}
        component="div"
        count={websites?.length || 0}
        rowsPerPage={rowsPerPage}
        page={page}
        onPageChange={handleChangePage}
        onRowsPerPageChange={handleChangeRowsPerPage}
      />
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={() => setSnackbar({ ...snackbar, open: false })}
          severity={snackbar.severity}
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Container>
  );
};

export default withAuth(Dashboard);

// Filename: app/globals.css
/* global.css */

@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

:root {
  --max-width: 1100px;
  --border-radius: 12px;
  --font-mono: ui-monospace, Menlo, Monaco, 'Cascadia Mono', 'Segoe UI Mono',
    'Roboto Mono', 'Oxygen Mono', 'Ubuntu Monospace', 'Source Code Pro',
    'Fira Mono', 'Droid Sans Mono', 'Courier New', monospace;
}

* {
  box-sizing: border-box;
  padding: 0;
  margin: 0;
}

html,
body {
  max-width: 100vw;
  overflow-x: hidden;
  font-family: 'Inter', sans-serif;
}

a {
  color: inherit;
  text-decoration: none;
}

/* Custom scrollbar styles */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
}

::-webkit-scrollbar-thumb {
  background: #888;
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: #555;
}


// Filename: app/layout.tsx
// Filename: app/layout.tsx

'use client';

import React, { useState } from 'react';
import { SessionProvider } from 'next-auth/react';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import { Box } from '@mui/material';
import Navigation from '@/components/Navigation';
import Sidebar from '@/components/Sidebar';
import ErrorBoundary from '@/components/ErrorBoundary';
import ErrorHandler from '@/components/ErrorHandler';
import { usePathname } from 'next/navigation';
import theme from '@/lib/theme';
import { ErrorContext } from '@/lib/ErrorContext';

export interface RootLayoutProps {
  children: React.ReactNode;
}

export default function RootLayout({ children }: RootLayoutProps) {
  const [error, setError] = useState<string | null>(null);
  const [mobileOpen, setMobileOpen] = useState(false);
  const [sidebarWidth, setSidebarWidth] = useState(280); // Initial sidebar width
  const pathname = usePathname();
  const isSignInPage = pathname === '/auth/signin';

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  const handleSidebarResize = (newWidth: number) => {
    setSidebarWidth(newWidth);
  };

  const handleCloseError = () => {
    setError(null);
  };

  return (
    <html lang="en">
      <body>
        <SessionProvider>
          <ThemeProvider theme={theme}>
            <CssBaseline />
            <ErrorContext.Provider value={{ setError }}>
              <ErrorBoundary>
                {!isSignInPage && (
                  <Box sx={{ display: 'flex', height: '100vh' }}>
                    {/* Navigation Bar */}
                    <Navigation sidebarWidth={sidebarWidth} onMenuClick={handleDrawerToggle} />

                    {/* Sidebar */}
                    <Sidebar
                      open={mobileOpen}
                      onClose={handleDrawerToggle}
                      sidebarWidth={sidebarWidth}
                      onSidebarResize={handleSidebarResize}
                    />

                    {/* Main Content Area */}
                    <Box
                      component="main"
                      sx={{
                        flexGrow: 1,
                        p: 3,
                        width: { sm: `calc(100% - ${sidebarWidth}px)` },
                        mt: '64px', // Offset for the AppBar (Navigation)
                      }}
                    >
                      {children}
                    </Box>
                  </Box>
                )}
                {isSignInPage && children}
                <ErrorHandler error={error} onClose={handleCloseError} />
              </ErrorBoundary>
            </ErrorContext.Provider>
          </ThemeProvider>
        </SessionProvider>
      </body>
    </html>
  );
}


// Filename: app/page.tsx
'use client';

import React, { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useSession } from 'next-auth/react';
import { CircularProgress } from '@mui/material';

const HomeClient: React.FC = () => {
  const { status } = useSession();
  const router = useRouter();

  useEffect(() => {
    if (status === 'authenticated') {
      router.push('/dashboard');
    } else if (status === 'unauthenticated') {
      router.push('/auth/signin');
    }
  }, [status, router]);

  if (status === 'loading') {
    return (
      <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '100vh' }}>
        <CircularProgress />
      </div>
    );
  }

  // Return null while waiting for redirect
  return null;
};

export default HomeClient;

// Filename: app/website/[websiteId]/page.tsx
// File: app/website/[websiteId]/page.tsx

'use client';

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import {
  Box,
  Typography,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
  CircularProgress,
  TablePagination,
  TableSortLabel,
  useTheme,
  useMediaQuery,
  Button,
  Grid,
  Card,
  CardContent,
  Snackbar,
} from '@mui/material';
import MuiAlert, { AlertProps } from '@mui/material/Alert';
import { SyncAlt as SyncIcon } from '@mui/icons-material';
import { Website, Page } from '@/types';
import { useError } from '@/lib/useError';
import IndexingStats from '@/components/IndexingStats';

type Order = 'asc' | 'desc';

interface HeadCell {
  id: keyof Page | 'impressions' | 'clicks' | 'actions';
  label: string;
  numeric: boolean;
  sortable: boolean;
}

const headCells: HeadCell[] = [
  { id: 'url', label: 'URL', numeric: false, sortable: true },
  { id: 'indexing_status', label: 'Status', numeric: false, sortable: true },
  { id: 'last_indexed_date', label: 'Last Crawled', numeric: false, sortable: true },
  { id: 'impressions', label: 'Impressions', numeric: true, sortable: true },
  { id: 'clicks', label: 'Clicks', numeric: true, sortable: true },
  { id: 'actions', label: 'Actions', numeric: false, sortable: false },
];

const Alert = React.forwardRef<HTMLDivElement, AlertProps>(function Alert(
  props,
  ref,
) {
  return <MuiAlert elevation={6} ref={ref} variant="filled" {...props} />;
});

const indexed: string = 'Submitted and indexed';

export default function WebsiteDetailsPage({ params }: { params: { websiteId: string } }) {
  const websiteId = parseInt(params.websiteId);
  const [website, setWebsite] = useState<Website | null>(null);
  const [allPages, setAllPages] = useState<Page[]>([]);
  const [loading, setLoading] = useState(true);
  const [syncing, setSyncing] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [order, setOrder] = useState<Order>('asc');
  const [orderBy, setOrderBy] = useState<keyof Page | 'impressions' | 'clicks'>('url');
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(25);
  const [analyticsData, setAnalyticsData] = useState<{ [key: string]: { impressions: number, clicks: number } }>({});
  const [submitting, setSubmitting] = useState<number | null>(null);
  const [snackbar, setSnackbar] = useState<{ open: boolean; message: string; severity: 'success' | 'error' }>({
    open: false,
    message: '',
    severity: 'success',
  });
  const [initialScanTime, setInitialScanTime] = useState<string | null>(null);
  const [isPolling, setIsPolling] = useState(false);
  const [pollingAttempts, setPollingAttempts] = useState(0);
  const MAX_POLLING_ATTEMPTS = 3;

  const setGlobalError = useError();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const cleanDomain = (domain: string): string => {
    return domain.replace(/^(sc-domain:)?(https?:\/\/)?(www\.)?/, '');
  };

  const fetchWebsiteDetails = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const websiteResponse = await fetch(`/api/websites/${websiteId}`);
      if (!websiteResponse.ok) {
        throw new Error('Failed to fetch website details');
      }
      const websiteData = await websiteResponse.json();
      setWebsite(websiteData);

      const pagesResponse = await fetch(`/api/websites/${websiteId}/pages?all=true`);
      if (!pagesResponse.ok) {
        throw new Error('Failed to fetch pages');
      }
      const pagesData = await pagesResponse.json();
      setAllPages(pagesData.pages || []);

      const urls = pagesData.pages.map((p: Page) => p.url);
      const analyticsResponse = await fetch(`/api/websites/${websiteId}/analytics?urls=${urls.join(',')}`);
      if (!analyticsResponse.ok) {
        throw new Error('Failed to fetch analytics data');
      }
      const analyticsData = await analyticsResponse.json();
      setAnalyticsData(analyticsData.data);

    } catch (err) {
      console.error('Error fetching website details:', err);
      setError('An error occurred while fetching website details');
      setGlobalError('Failed to load website details. Please try again later.');
    } finally {
      setLoading(false);
    }
  }, [websiteId, setGlobalError]);

  useEffect(() => {
    fetchWebsiteDetails();
  }, [fetchWebsiteDetails]);

  const handleRequestSort = (property: keyof Page | 'impressions' | 'clicks') => {
    const isAsc = orderBy === property && order === 'asc';
    setOrder(isAsc ? 'desc' : 'asc');
    setOrderBy(property);
  };

  const handleChangePage = (event: unknown, newPage: number) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event: React.ChangeEvent<HTMLInputElement>) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const handleSubmitForIndexing = async (pageId: number) => {
    try {
      setSubmitting(pageId);
      const response = await fetch(`/api/websites/${websiteId}/pages/${pageId}/submit-for-indexing`, {
        method: 'POST',
      });

      if (!response.ok) {
        throw new Error('Failed to submit page for indexing');
      }

      const result = await response.json();
      setGlobalError(null);
      setSnackbar({
        open: true,
        message: result.message || 'Page submitted for indexing successfully',
        severity: 'success',
      });

      // Refresh the page data
      fetchWebsiteDetails();
    } catch (err) {
      console.error('Error submitting page for indexing:', err);
      setGlobalError('Failed to submit page for indexing. Please try again later.');
      setSnackbar({
        open: true,
        message: 'Failed to submit page for indexing',
        severity: 'error',
      });
    } finally {
      setSubmitting(null);
    }
  };

  const handleSyncPages = async () => {
    try {
      setSyncing(true);
      setPollingAttempts(0);
      const response = await fetch(`/api/websites/${websiteId}/toggle-indexing`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ enabled: true }),
      });
      if (!response.ok) {
        throw new Error('Failed to sync pages');
      }
      const data = await response.json();
      setInitialScanTime(data.initialScanTime);
      setIsPolling(true);
      setSnackbar({
        open: true,
        message: 'Sync pages started',
        severity: 'success',
      });
    } catch (err) {
      console.error('Error syncing pages:', err);
      setGlobalError('Failed to sync pages. Please try again later.');
      setSnackbar({
        open: true,
        message: 'Failed to sync pages',
        severity: 'error',
      });
    } finally {
      setSyncing(false);
    }
  };

  const checkJobStatus = useCallback(async () => {
    if (!initialScanTime) return;
  
    try {
      const response = await fetch(`/api/websites/${websiteId}/toggle-indexing?initialScanTime=${initialScanTime}`);
      if (!response.ok) {
        throw new Error('Failed to check sync status');
      }
      const data = await response.json();
      
      if (data.isCompleted) {
        setIsPolling(false);
        await fetchWebsiteDetails();
        setSnackbar({
          open: true,
          message: 'Pages sync completed',
          severity: 'success',
        });
      } else {
        setPollingAttempts(prevAttempts => prevAttempts + 1);
        if (pollingAttempts >= MAX_POLLING_ATTEMPTS) {
          setIsPolling(false);
        }
      }
    } catch (error) {
      console.error('Error checking sync status:', error);
      setIsPolling(false);
      setSnackbar({
        open: true,
        message: 'Error checking sync status',
        severity: 'error',
      });
    }
  }, [initialScanTime, websiteId, fetchWebsiteDetails, pollingAttempts]);
  
  // Modify the useEffect hook for polling:
  useEffect(() => {
    let intervalId: NodeJS.Timeout;
  
    if (isPolling && pollingAttempts < MAX_POLLING_ATTEMPTS) {
      intervalId = setInterval(checkJobStatus, 5000); // Poll every 5 seconds
    } else if (pollingAttempts >= MAX_POLLING_ATTEMPTS) {
      setIsPolling(false);
    }
  
    return () => {
      if (intervalId) {
        clearInterval(intervalId);
      }
    };
  }, [isPolling, checkJobStatus, pollingAttempts]);


  const getSubmitButtonColor = (status: string) => {
    return status !== indexed ? theme.palette.error.light : theme.palette.primary.main;
  };

  const sortedAndPaginatedPages = useMemo(() => {
    const sortedPages = [...allPages].sort((a, b) => {
      const aValue = orderBy === 'impressions' || orderBy === 'clicks' 
        ? (analyticsData[a.url]?.[orderBy] || 0) 
        : a[orderBy as keyof Page];
      const bValue = orderBy === 'impressions' || orderBy === 'clicks'
        ? (analyticsData[b.url]?.[orderBy] || 0)
        : b[orderBy as keyof Page];

      if (typeof aValue === 'string' && typeof bValue === 'string') {
        return order === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
      } else if (aValue instanceof Date && bValue instanceof Date) {
        return order === 'asc' ? aValue.getTime() - bValue.getTime() : bValue.getTime() - aValue.getTime();
      } else if (typeof aValue === 'number' && typeof bValue === 'number') {
        return order === 'asc' ? aValue - bValue : bValue - aValue;
      }
      return 0;
    });

    const startIndex = page * rowsPerPage;
    const endIndex = startIndex + rowsPerPage;
    return sortedPages.slice(startIndex, endIndex);
  }, [allPages, order, orderBy, analyticsData, page, rowsPerPage]);

  if (loading && allPages.length === 0) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
        <CircularProgress />
      </Box>);
  }

  if (error) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
        <Alert severity="error">{error}</Alert>
      </Box>
    );
  }

  return (
    <Box sx={{ flexGrow: 1, p: 3 }}>
      <Grid container spacing={3} alignItems="center" sx={{ mb: 3 }}>
        <Grid item xs={12} sm={6}>
          <Typography variant="h4" component="h1">
            {website ? cleanDomain(website.domain) : 'Website Details'}
          </Typography>
        </Grid>
        <Grid item xs={12} sm={6} sx={{ display: 'flex', justifyContent: 'flex-end' }}>
          <Button
            variant="outlined"
            startIcon={syncing ? <CircularProgress size={20} color="inherit" /> : <SyncIcon />}
            onClick={handleSyncPages}
            disabled={syncing || isPolling}
          >
            {syncing ? 'Syncing...' : isPolling ? 'Sync in progress...' : 'Sync Pages'}
          </Button>
        </Grid>
      </Grid>

      <IndexingStats websiteId={websiteId} />

      <Typography variant="h5" gutterBottom sx={{ mt: 4, mb: 2 }}>
        Pages
      </Typography>

      {allPages.length > 0 ? (
        <Paper>
          {isMobile ? (
            // Mobile view
            <Box>
              {sortedAndPaginatedPages.map((page) => (
                <Card key={page.id} sx={{ mb: 2 }}>
                  <CardContent>
                    <Typography variant="subtitle1" sx={{ mb: 1, wordBreak: 'break-all' }}>
                      {page.url}
                    </Typography>
                    <Typography variant="body2">Status: {page.indexing_status}</Typography>
                    <Typography variant="body2">
                      Last Crawled: {new Date(page.last_indexed_date).toLocaleString()}
                    </Typography>
                    <Typography variant="body2">
                      Impressions: {analyticsData[page.url]?.impressions || 0}
                    </Typography>
                    <Typography variant="body2">
                      Clicks: {analyticsData[page.url]?.clicks || 0}
                    </Typography>
                    <Button
                      variant="contained"
                      size="small"
                      onClick={() => handleSubmitForIndexing(page.id)}
                      disabled={
                        submitting === page.id ||
                        new Date(page.last_indexed_date).getTime() > Date.now() - 24 * 60 * 60 * 1000
                      }
                      sx={{ 
                        mt: 1, 
                        backgroundColor: getSubmitButtonColor(page.indexing_status),
                        '&:hover': {
                          backgroundColor: theme.palette.error.main,
                        },
                      }}
                    >
                      {submitting === page.id ? <CircularProgress size={24} /> : 'Submit'}
                    </Button>
                  </CardContent>
                </Card>
              ))}
            </Box>
          ) : (
            // Desktop view
            <TableContainer>
              <Table sx={{ minWidth: 300 }} aria-label="website pages table">
                <TableHead>
                  <TableRow>
                    {headCells.map((headCell) => (
                      <TableCell
                        key={headCell.id}
                        align={headCell.numeric ? 'right' : 'left'}
                        sortDirection={orderBy === headCell.id ? order : false}
                      >
                        {headCell.sortable ? (
                          <TableSortLabel
                            active={orderBy === headCell.id}
                            direction={orderBy === headCell.id ? order : 'asc'}
                            onClick={() => handleRequestSort(headCell.id)}
                          >
                            {headCell.label}
                          </TableSortLabel>
                        ) : (
                          headCell.label
                        )}
                      </TableCell>
                    ))}
                  </TableRow>
                </TableHead>
                <TableBody>
                  {sortedAndPaginatedPages.map((page) => (
                    <TableRow key={page.id}>
                      <TableCell
                        component="th"
                        scope="row"
                        sx={{
                          maxWidth: 300,
                          overflow: 'hidden',
                          textOverflow: 'ellipsis',
                          whiteSpace: 'nowrap',
                        }}
                      >
                        {page.url}
                      </TableCell>
                      <TableCell>{page.indexing_status}</TableCell>
                      <TableCell>{new Date(page.last_indexed_date).toLocaleString()}</TableCell>
                      <TableCell align="right">{analyticsData[page.url]?.impressions || 0}</TableCell>
                      <TableCell align="right">{analyticsData[page.url]?.clicks || 0}</TableCell>
                      <TableCell>
                        <Button
                          variant="contained"
                          size="small"
                          onClick={() => handleSubmitForIndexing(page.id)}
                          disabled={
                            submitting === page.id ||
                            new Date(page.last_indexed_date).getTime() > Date.now() - 24 * 60 * 60 * 1000
                          }
                          sx={{ 
                            backgroundColor: getSubmitButtonColor(page.indexing_status),
                            '&:hover': {
                              backgroundColor: theme.palette.error.main,
                            },
                          }}
                        >
                          {submitting === page.id ? <CircularProgress size={24} /> : 'Submit'}
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          )}
          <TablePagination
            rowsPerPageOptions={[10, 25, 50, 100]}
            component="div"
            count={allPages.length}
            rowsPerPage={rowsPerPage}
            page={page}
            onPageChange={handleChangePage}
            onRowsPerPageChange={handleChangeRowsPerPage}
          />
        </Paper>
      ) : (
        <Alert severity="info">No pages found for this website.</Alert>
      )}
  
      <Snackbar
        open={snackbar.open}
        autoHideDuration={6000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert
          onClose={() => setSnackbar({ ...snackbar, open: false })}
          severity={snackbar.severity}
          sx={{ width: '100%' }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Box>
  );
}

// Filename: combine.js
const fs = require('fs');
const path = require('path');

const outputFile = 'all-code.txt';
const extensions = ['.js', '.ts', '.tsx', '.css', '.env'];   // file extensions to include
const excludedDirs = ['node_modules', '.next'];              // Directories to exclude

function combineFiles(dir) {
  // Skip the directory if it's in the excluded list
  if (excludedDirs.includes(path.basename(dir))) {
    return;
  }

  fs.readdirSync(dir).forEach((file) => {
    const fullPath = path.join(dir, file);
    const stat = fs.statSync(fullPath);

    if (stat.isDirectory()) {
      combineFiles(fullPath);
    } else if (extensions.includes(path.extname(fullPath))) {
      // Get the relative path of the file
      const relativePath = path.relative(__dirname, fullPath);

      // Read the file content
      let data = fs.readFileSync(fullPath, 'utf8');

      // Add the path and filename as a comment in the first line
      data = `// Filename: ${relativePath}\n${data}`;

      // Add an empty line at the end of the file content
      data = `${data}\n`;

      // Append the modified data to the output file
      fs.appendFileSync(outputFile, `\n${data}`);
    }
  });
}

// Clear the output file if it exists
fs.writeFileSync(outputFile, '', 'utf8');

// Start combining from the current directory
combineFiles(__dirname);


// Filename: components/AnalyticsSummary.tsx
import React, { useState, useEffect } from 'react';
import { Grid, Paper, Typography } from '@mui/material';

interface AnalyticsData {
  totalVisits: number;
  averageSessionDuration: string;
  bounceRate: string;
}

const AnalyticsSummary: React.FC = () => {
  const [analyticsData, setAnalyticsData] = useState<AnalyticsData | null>(null);

  useEffect(() => {
    fetchAnalyticsData();
  }, []);

  const fetchAnalyticsData = async () => {
    try {
      const response = await fetch('/api/analytics/summary');
      const data = await response.json();
      setAnalyticsData(data);
    } catch (error) {
      console.error('Error fetching analytics data:', error);
    }
  };

  if (!analyticsData) {
    return <Typography>Loading analytics data...</Typography>;
  }

  return (
    <Grid container spacing={3}>
      <Grid item xs={4}>
        <Paper elevation={2} sx={{ p: 2, textAlign: 'center' }}>
          <Typography variant="h6">{analyticsData.totalVisits}</Typography>
          <Typography variant="body2">Total Visits</Typography>
        </Paper>
      </Grid>
      <Grid item xs={4}>
        <Paper elevation={2} sx={{ p: 2, textAlign: 'center' }}>
          <Typography variant="h6">{analyticsData.averageSessionDuration}</Typography>
          <Typography variant="body2">Avg. Session Duration</Typography>
        </Paper>
      </Grid>
      <Grid item xs={4}>
        <Paper elevation={2} sx={{ p: 2, textAlign: 'center' }}>
          <Typography variant="h6">{analyticsData.bounceRate}%</Typography>
          <Typography variant="body2">Bounce Rate</Typography>
        </Paper>
      </Grid>
    </Grid>
  );
};

export default AnalyticsSummary;

// Filename: components/ErrorBoundary.tsx
// File: components/ErrorBoundary.tsx
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AppError } from '@/utils/errors';

interface Props {
  children: React.ReactNode;
  fallback?: React.ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
    error: null,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }
      return (
        <div>
          <h1>Something went wrong</h1>
          <p>{this.state.error instanceof AppError ? this.state.error.message : 'An unexpected error occurred'}</p>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;

// Filename: components/ErrorHandler.tsx
// components/ErrorHandler.tsx
import React from 'react';
import { Alert, AlertTitle, Snackbar } from '@mui/material';

interface ErrorHandlerProps {
  error: string | null;
  onClose: () => void;
}

const ErrorHandler: React.FC<ErrorHandlerProps> = ({ error, onClose }) => {
  return (
    <Snackbar open={!!error} autoHideDuration={6000} onClose={onClose}>
      <Alert onClose={onClose} severity="error" sx={{ width: '100%' }}>
        <AlertTitle>Error</AlertTitle>
        {error}
      </Alert>
    </Snackbar>
  );
};

export default ErrorHandler;

// Filename: components/IndexingStats.tsx
// Filename: components/IndexingStats.tsx

import React, { useState, useEffect } from 'react';
import { Grid, Typography, Paper, CircularProgress, Alert } from '@mui/material';
import { IndexingStatsData } from '@/types';

interface IndexingStatsProps {
  websiteId: number;
}

const IndexingStats: React.FC<IndexingStatsProps> = ({ websiteId }) => {
  const [indexingStats, setIndexingStats] = useState<IndexingStatsData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchIndexingStats();
  }, [websiteId]);

  const fetchIndexingStats = async () => {
    try {
      setLoading(true);
      setError(null);

      const response = await fetch(`/api/websites/${websiteId}/indexing-stats`);
      if (!response.ok) {
        throw new Error('Failed to fetch indexing stats');
      }

      const data = await response.json();
      setIndexingStats(data.indexingStats?.indexingStats || null);

    } catch (err) {
      console.error('Error fetching indexing stats:', err);
      setError('An error occurred while fetching indexing stats');
    } finally {
      setLoading(false);
    }
  };
 
  if (error) {
    return <Alert severity="error">{error}</Alert>;
  }

  return (
    <Paper elevation={3} sx={{ p: 3, mb: 4 }}>
      <Grid container spacing={2}>
        <Grid item xs={12} sm={6} md={3}>
          <Typography variant="subtitle1">Total Pages</Typography>
          <Typography variant="h6">{indexingStats?.total_pages || 0}</Typography>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Typography variant="subtitle1">Indexed Pages</Typography>
          <Typography variant="h6">{indexingStats?.indexed_pages || 0}</Typography>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Typography variant="subtitle1">Not Indexed Pages</Typography>
          <Typography variant="h6">{indexingStats?.not_indexed_pages || 0}</Typography>
        </Grid>
        <Grid item xs={12} sm={6} md={3}>
          <Typography variant="subtitle1">Auto-indexing</Typography>
          <Typography variant="h6">Enabled</Typography>
        </Grid>
      </Grid>
    </Paper>
  );
};

export default IndexingStats;


// Filename: components/Navigation.tsx
// Filename: components/Navigation.tsx

import React from 'react';
import { AppBar, Toolbar, Typography, IconButton, Button } from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import { useSession, signOut } from 'next-auth/react';

interface NavigationProps {
  sidebarWidth: number;
  onMenuClick: () => void;
}

const Navigation: React.FC<NavigationProps> = ({ sidebarWidth, onMenuClick }) => {
  const { data: session } = useSession();

  return (
    <AppBar
      position="fixed"
      sx={{
        zIndex: (theme) => theme.zIndex.drawer + 1,
        width: { sm: `calc(100% - ${sidebarWidth}px)` },
        ml: { sm: `${sidebarWidth}px` },
      }}
    >
      <Toolbar>
        <IconButton
          color="inherit"
          aria-label="open drawer"
          edge="start"
          onClick={onMenuClick}
          sx={{ mr: 2, display: { sm: 'none' } }}
        >
          <MenuIcon />
        </IconButton>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          {/* Placeholder for alignment */}
        </Typography>
        {session ? (
          <>
            <Typography variant="body1" sx={{ marginRight: 2 }}>
              {session.user?.name}
            </Typography>
            <Button color="inherit" onClick={() => signOut()}>
              Logout
            </Button>
          </>
        ) : null}
      </Toolbar>
    </AppBar>
  );
};

export default Navigation;


// Filename: components/Sidebar.tsx
import React, { useState, useEffect } from 'react';
import { Box, Drawer, List, ListItem, ListItemIcon, ListItemText, IconButton, CircularProgress, useTheme, useMediaQuery } from '@mui/material';
import { Dashboard as DashboardIcon, Web as WebIcon, Close as CloseIcon } from '@mui/icons-material';
import Link from 'next/link';
import Image from 'next/image';
import { Website } from '@/types';

interface SidebarProps {
  open: boolean;
  onClose?: () => void;
  sidebarWidth: number;
  onSidebarResize: (newWidth: number) => void;
}

const MOBILE_SIDEBAR_WIDTH = 280; // Fixed width for mobile

const Sidebar: React.FC<SidebarProps> = ({ open, onClose, sidebarWidth, onSidebarResize }) => {
  const [websites, setWebsites] = useState<Website[]>([]);
  const [loading, setLoading] = useState(true);
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  useEffect(() => {
    fetchWebsites();
  }, []);

  const fetchWebsites = async () => {
    try {
      setLoading(true);
      const response = await fetch('/api/websites');
      if (!response.ok) {
        throw new Error('Failed to fetch websites');
      }
      const data = await response.json();
      setWebsites(data.filter((website: Website) => website.indexing_enabled));
    } catch (error) {
      console.error('Error fetching websites:', error);
    } finally {
      setLoading(false);
    }
  };

  const extractDomainName = (domain: string) => {
    return domain.replace(/^sc-domain:/, '').replace(/^https?:\/\//, '').replace(/^www\./, '');
  };

  const handleMouseDown = (e: React.MouseEvent) => {
    if (isMobile) return; // Disable resizing on mobile
    e.preventDefault();
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
  };

  const handleMouseMove = (e: MouseEvent) => {
    if (isMobile) return; // Disable resizing on mobile
    const newWidth = Math.max(200, e.clientX); // Set a minimum sidebar width
    onSidebarResize(newWidth);
  };

  const handleMouseUp = () => {
    document.removeEventListener('mousemove', handleMouseMove);
    document.removeEventListener('mouseup', handleMouseUp);
  };

  const drawerContent = (
    <Box sx={{ width: isMobile ? MOBILE_SIDEBAR_WIDTH : sidebarWidth, height: '100%', display: 'flex', flexDirection: 'column', position: 'relative', overflow: 'hidden' }}>
      <Box
        sx={{
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          padding: 2,
          height: '64px',
          position: 'relative',
        }}
      >
        <Link href="/" passHref>
          <Image src="/images/logo.png" alt="App Logo" width={180} height={40} style={{ cursor: 'pointer' }} priority />
        </Link>
        {onClose && (
          <IconButton onClick={onClose} sx={{ position: 'absolute', right: 8, display: { sm: 'none' } }}>
            <CloseIcon />
          </IconButton>
        )}
      </Box>

      <List>
        <Link href="/dashboard" passHref legacyBehavior>
          <ListItem button="true">
            <ListItemIcon>
              <DashboardIcon />
            </ListItemIcon>
            <ListItemText primary="Dashboard" />
          </ListItem>
        </Link>
      </List>

      <List>
        <ListItem>
          <ListItemText primary="Auto-Indexed Websites" />
        </ListItem>
        {loading ? (
          <ListItem>
            <CircularProgress size={24} />
          </ListItem>
        ) : websites.length > 0 ? (
          websites.map((website) => (
            <Link href={`/website/${website.id}`} passHref key={website.id} legacyBehavior>
              <ListItem button="true">
                <ListItemIcon>
                  <WebIcon />
                </ListItemIcon>
                <ListItemText primary={extractDomainName(website.domain)} />
              </ListItem>
            </Link>
          ))
        ) : (
          <ListItem>
            <ListItemText primary="No enabled websites" />
          </ListItem>
        )}
      </List>

      {/* Resizable handle only visible for desktop sidebar */}
      {!isMobile && (
        <Box
          sx={{
            width: '5px',
            cursor: 'col-resize',
            position: 'absolute',
            right: 0,
            top: 0,
            height: '100vh',
            zIndex: 1000,
            backgroundColor: 'transparent',
          }}
          onMouseDown={handleMouseDown}
        />
      )}
    </Box>
  );

  return (
    <Box component="nav" sx={{ width: { sm: isMobile ? MOBILE_SIDEBAR_WIDTH : sidebarWidth }, flexShrink: { sm: 0 } }}>
      {/* Mobile Sidebar */}
      <Drawer
        variant="temporary"
        open={open}
        onClose={onClose}
        ModalProps={{ keepMounted: true }}
        sx={{
          display: { xs: 'block', sm: 'none' },
          zIndex: (theme) => theme.zIndex.drawer + 2,
          '& .MuiDrawer-paper': { boxSizing: 'border-box', width: MOBILE_SIDEBAR_WIDTH, overflow: 'hidden' },
        }}
      >
        {drawerContent}
      </Drawer>

      {/* Desktop Sidebar */}
      <Drawer
        variant="permanent"
        sx={{
          display: { xs: 'none', sm: 'block' },
          '& .MuiDrawer-paper': { boxSizing: 'border-box', width: sidebarWidth, overflow: 'hidden' },
        }}
        open
      >
        {drawerContent}
      </Drawer>
    </Box>
  );
};

export default Sidebar;

// Filename: components/WebsiteList.tsx
import React from 'react';
import { 
  List, 
  ListItem, 
  ListItemText, 
  ListItemSecondaryAction, 
  Switch, 
  Typography, 
  Button 
} from '@mui/material';
import { Refresh as RefreshIcon } from '@mui/icons-material';
import { Website } from '@/types';

interface WebsiteListProps {
  websites: Website[];
  onToggleIndexing: (websiteId: number, currentStatus: boolean) => Promise<void>;
  onRefresh: () => Promise<void>;
}

const WebsiteList: React.FC<WebsiteListProps> = ({ websites, onToggleIndexing, onRefresh }) => {
  const handleToggle = async (websiteId: number, currentStatus: boolean) => {
    await onToggleIndexing(websiteId, currentStatus);
  };

  const formatLastScanned = (date: Date | null | undefined): string => {
    if (!date) return 'None';
    const formattedDate = new Date(date).toLocaleString();
    return formattedDate !== 'Invalid Date' ? formattedDate : 'None';
  };

  return (
    <>
      <Button
        startIcon={<RefreshIcon />}
        onClick={onRefresh}
        variant="outlined"
        style={{ marginBottom: '1rem' }}
      >
        Refresh from Search Console
      </Button>
      <List>
        {websites.map((website) => (
          <ListItem key={website.id} component="div">
            <ListItemText 
              primary={website.domain}
              secondary={`Last scanned: ${formatLastScanned(website.last_robots_scan)}`}
            />
            <ListItemSecondaryAction>
              <Switch
                edge="end"
                onChange={() => handleToggle(website.id, website.indexing_enabled)}
                checked={website.indexing_enabled}
              />
            </ListItemSecondaryAction>
          </ListItem>
        ))}
        {websites.length === 0 && (
          <Typography variant="body2" color="textSecondary" align="center">
            No websites found. Click 'Refresh from Search Console' to fetch your properties.
          </Typography>
        )}
      </List>
    </>
  );
};

export default WebsiteList;

// Filename: components/withAuth.tsx
'use client';

import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { useEffect } from 'react';
import { CircularProgress, Box } from '@mui/material';

export function withAuth<P extends object>(WrappedComponent: React.ComponentType<P>) {
  return function WithAuth(props: P) {
    const { data: session, status } = useSession();
    const router = useRouter();

    useEffect(() => {
      if (status === 'loading') return; // Do nothing while loading
      if (!session && status !== 'loading') {
        router.push('/auth/signin');
      }
    }, [session, status, router]);

    if (status === 'loading') {
      return (
        <Box display="flex" justifyContent="center" alignItems="center" height="100vh">
          <CircularProgress />
        </Box>
      );
    }

    if (status === 'authenticated') {
      return <WrappedComponent {...props} />;
    }

    return null; // Render nothing while redirecting
  };
}


// Filename: config/index.ts
// File: config/index.ts

import { config } from 'dotenv';

// Load environment variables from .env file
config();

const CONFIG = {
  database: {
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT || '5432', 10),
    name: process.env.DB_NAME,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
  },
  google: {
    clientId: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    clientEmail: process.env.GOOGLE_CLIENT_EMAIL,
    privateKey: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
  },
  nextAuth: {
    url: process.env.NEXTAUTH_URL,
    secret: process.env.NEXTAUTH_SECRET,
  },
  apiKeys: {
    dailyIndexing: process.env.DAILY_INDEXING_API_KEY,
  },
};

export default CONFIG;

// Filename: lib/ErrorContext.ts
// lib/ErrorContext.ts
import { createContext } from 'react';

interface ErrorContextType {
  setError: (error: string | null) => void;
}

export const ErrorContext = createContext<ErrorContextType>({
  setError: () => {},
});

// Filename: lib/db.ts
import { Pool } from 'pg';
import CONFIG from '@/config';

const pool = new Pool({
  host: CONFIG.database.host,
  port: CONFIG.database.port,
  database: CONFIG.database.name,
  user: CONFIG.database.user,
  password: CONFIG.database.password,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

export default pool;

// Filename: lib/googleAnalytics.ts
// lib/googleAnalytics.ts
import { BetaAnalyticsDataClient } from '@google-analytics/data';
import { getValidAccessToken } from './tokenManager';
import { getWebsiteById } from '@/models';
import { AuthorizationError } from '@/utils/errors';

function cleanDomain(inputDomain: string): string {
  let cleanedDomain = inputDomain.replace(/^sc-domain:/, '');
  try {
    const url = new URL(cleanedDomain);
    cleanedDomain = url.hostname;
  } catch {
    // If it's not a valid URL, assume it's already just a domain
  }
  cleanedDomain = cleanedDomain.replace(/^www\./, '');
  return cleanedDomain;
}

export async function fetchGA4Data(analytics: any, domain: string) {
  try {
    // List all GA4 properties
    const propertiesResponse = await analytics.accountSummaries.list({
      pageSize: 100  // Adjust this value based on the number of properties you expect
    });
    const properties = propertiesResponse.data.accountSummaries
      .flatMap((account: any) => account.propertySummaries || [])
      .filter((prop: any) => prop.property);

    // Find the property that matches the domain
    const property = properties.find((prop: any) => {
      const propDisplayName = cleanDomain(prop.displayName);
      const cleanedDomain = cleanDomain(domain);
      return propDisplayName === cleanedDomain;
    });

    if (!property) {
      console.log(`No matching GA4 property found for domain: ${domain}`);
      return { propertyId: null, dataStreamId: null };
    }

    const propertyId = property.property.split('/').pop();

    // List data streams for the found property
    const dataStreamsResponse = await analytics.properties.dataStreams.list({
      parent: `properties/${propertyId}`
    });
    const dataStreams = dataStreamsResponse.data.dataStreams || [];

    // Find the first web data stream (or any if no web stream is found)
    const dataStream = dataStreams.find((stream: any) => stream.type === 'WEB_DATA_STREAM') || dataStreams[0];

    const dataStreamId = dataStream ? dataStream.name.split('/').pop() : null;

    console.log(`Found GA4 data for ${domain}: Property ID: ${propertyId}, Data Stream ID: ${dataStreamId}`);

    return {
      propertyId: propertyId,
      dataStreamId: dataStreamId
    };
  } catch (error) {
    console.error(`Error fetching GA4 data for ${domain}:`, error);
    return { propertyId: null, dataStreamId: null };
  }
}

export async function getGA4AnalyticsData(websiteId: number, urls: string[]) {
  try {
    const { website } = await getWebsiteById(websiteId);
    if (!website || !website.ga4_property_id) {
      throw new Error('Website or GA4 property ID not found');
    }

    const accessToken = await getValidAccessToken(website.user_id);

    console.log(`Fetching GA4 data for property ID: ${website.ga4_property_id}`);
    console.log(`Using access token: ${accessToken.substring(0, 10)}...`);
    console.log(`Querying for URLs:`, urls);

    const response = await fetch(
      `https://analyticsdata.googleapis.com/v1beta/properties/${website.ga4_property_id}:runReport`,
      {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${accessToken}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          dateRanges: [{ startDate: '30daysAgo', endDate: 'today' }],
          dimensions: [{ name: 'pagePath' }],
          metrics: [
            { name: 'screenPageViews' },
            { name: 'engagementRate' },
          ],
          dimensionFilter: {
            orGroup: {
              expressions: urls.map(url => ({
                filter: {
                  fieldName: 'pagePath',
                  stringFilter: {
                    matchType: 'CONTAINS',
                    value: url,
                  },
                },
              })),
            },
          },
        }),
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      console.error(`Google Analytics API error (${response.status}):`, errorText);
      throw new Error(`Google Analytics API responded with status ${response.status}: ${errorText}`);
    }

    const data = await response.json();
    console.log('Raw API Response:', JSON.stringify(data, null, 2));

    const result: { [key: string]: { impressions: number, clicks: number } } = {};

    if (data.rows && data.rows.length > 0) {
      data.rows.forEach((row: any) => {
        const url = row.dimensionValues[0].value;
        const impressions = parseInt(row.metricValues[0].value || '0', 10);
        const engagementRate = parseFloat(row.metricValues[1].value || '0');
        const clicks = Math.round(impressions * engagementRate);

        result[url] = { impressions, clicks };
      });
    } else {
      console.log('No data returned from Google Analytics API');
    }

    console.log('Processed result:', result);
    return result;
  } catch (error) {
    console.error('Error fetching GA4 analytics data:', error);
    if (error instanceof AuthorizationError) {
      throw error;
    }
    throw new Error(`Failed to fetch analytics data: ${error.message}`);
  }
}

// Filename: lib/googleSearchConsole.ts
import { google } from 'googleapis';
import { OAuth2Client } from 'google-auth-library';
import { getWebsitesByUserId, getWebsiteById, createWebsite, updateWebsite } from '@/models';
import { IndexingStatus } from '@/types';
import { fetchGA4Data } from './googleAnalytics';
import CONFIG from '@/config';

const oauth2Client = new OAuth2Client(
  CONFIG.google.clientId,
  CONFIG.google.clientSecret
);

async function rateLimitedFetch<T>(items: T[], fetchFn: (item: T) => Promise<any>, rateLimit: number) {
  const results = [];
  for (let i = 0; i < items.length; i += rateLimit) {
    const batch = items.slice(i, i + rateLimit);
    const batchResults = await Promise.all(batch.map(fetchFn));
    results.push(...batchResults);
    if (i + rateLimit < items.length) {
      await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second between batches
    }
  }
  return results;
}

export async function fetchAndStoreWebsites(userId: number, accessToken: string) {
  try {
    oauth2Client.setCredentials({
      access_token: accessToken,
    });

    const searchconsole = google.searchconsole({ version: 'v1', auth: oauth2Client });
    const analytics = google.analyticsadmin({ version: 'v1beta', auth: oauth2Client });

    const sites = await searchconsole.sites.list();
    const { websites: existingWebsites } = await getWebsitesByUserId(userId);

    const updatedWebsites = new Set<string>();

    if (sites.data.siteEntry) {
      for (const site of sites.data.siteEntry) {
        //const domain = cleanDomain(site.siteUrl);
        const domain = site.siteUrl;
        const ga4Data = await fetchGA4Data(analytics, domain);

        const existingWebsite = existingWebsites.find(w => w.domain === domain);

        if (existingWebsite) {
          await updateWebsite(existingWebsite.id, {
            ga4_property_id: ga4Data.propertyId,
            ga4_data_stream_id: ga4Data.dataStreamId,
            indexing_enabled: existingWebsite.indexing_enabled, // Preserve existing indexing status
          });
        } else {
          await createWebsite({
            user_id: userId,
            domain: domain,
            indexing_enabled: false, // New websites are set to false by default
            ga4_property_id: ga4Data.propertyId,
            ga4_data_stream_id: ga4Data.dataStreamId,
          });
        }

        updatedWebsites.add(domain);
      }
    }

    // For websites no longer in Google Search Console, we set indexing_enabled to false
    for (const existingWebsite of existingWebsites) {
      if (!updatedWebsites.has(existingWebsite.domain)) {
        await updateWebsite(existingWebsite.id, { indexing_enabled: false });
      }
    }
  } catch (error) {
    console.error('Error fetching and storing websites:', error);
    throw error;
  }
}

export async function fetchBulkIndexingStatus(websiteId: number, domain: string, accessToken: string, urls: string[]): Promise<Array<{ url: string, lastIndexedDate: string | null, indexingStatus: IndexingStatus }>> {
  oauth2Client.setCredentials({
    access_token: accessToken,
  });

  const searchconsole = google.searchconsole({ version: 'v1', auth: oauth2Client });

  try {
    const fetchUrl = async (url: string) => {
      try {
        const response = await searchconsole.urlInspection.index.inspect({
          requestBody: {
            inspectionUrl: url,
            siteUrl: domain,
          },
        });

        const result = response.data.inspectionResult;
        return {
          url: url,
          lastIndexedDate: result?.indexStatusResult?.lastCrawlTime || null,
          indexingStatus: result?.indexStatusResult?.coverageState
        };
      } catch (error) {
        console.error(`Error inspecting URL ${url}:`, error);
        return {
          url: url,
          lastIndexedDate: null,
          indexingStatus: 'error' as IndexingStatus
        };
      }
    };

    // Use rateLimitedFetch to process URLs with rate limiting
    const results = await rateLimitedFetch(urls, fetchUrl, 100); // Process 100 URLs per second

    return results;

  } catch (error) {
    console.error('Error fetching indexing status:', error);
    throw error;
  }
}

export async function submitUrlForIndexing(domain: string, url: string, accessToken: string): Promise<void> {
  oauth2Client.setCredentials({
    access_token: accessToken,
  });

  const indexing = google.indexing({ version: 'v3', auth: oauth2Client });

  try {
    await indexing.urlNotifications.publish({
      requestBody: {
        url: url,
        type: 'URL_UPDATED',
      },
    });
    console.log(`Submitted URL for indexing: ${url}`);
  } catch (error) {
    console.error(`Error submitting URL for indexing: ${url}`, error);
    throw new Error('Failed to submit URL for indexing');
  }
}

export async function getPageImpressionsAndClicks(websiteId: number, urls: string[], accessToken: string) {
  const oauth2Client = new OAuth2Client();
  oauth2Client.setCredentials({
    access_token: accessToken,
  });

  const searchconsole = google.searchconsole({ version: 'v1', auth: oauth2Client });

  try {
    const { website } = await getWebsiteById(websiteId);
    if (!website) {
      throw new Error('Website not found');
    }

    const startDate = new Date();
    startDate.setDate(startDate.getDate() - 30); // Last 30 days
    const endDate = new Date();

    const response = await searchconsole.searchanalytics.query({
      siteUrl: website.domain,
      requestBody: {
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0],
        dimensions: ['page'],
        rowLimit: urls.length,
      },
    });
    //console.log('Response: ', response.data.rows);

    const result: { [key: string]: { impressions: number, clicks: number } } = {};

    // Initialize result with all input URLs set to zero impressions and clicks
    urls.forEach(url => {
      result[url] = { impressions: 0, clicks: 0 };
    });

    if (response.data.rows) {
      response.data.rows.forEach((row: any) => {
        const url = row.keys[0];
        if (urls.includes(url)) {
          result[url] = {
            impressions: row.impressions,
            clicks: row.clicks,
          };
        }
      });
    }
    //console.log('Result: ', result);
    return result;

  } catch (error) {
    console.error('Error fetching Search Console data:', error);
    throw new Error('Failed to fetch Search Console data');
  }
}

// Filename: lib/jobQueue.ts
import { processSingleWebsite } from '@/lib/sitemapProcessor';
import { processWebsiteForScheduledJob } from '@/lib/scheduledSitemapProcessor';
import { getWebsiteById } from '@/models';

interface Job {
  websiteId: number;
  type: 'ui' | 'scheduled';
}

class JobQueue {
  private queue: Job[] = [];
  private isProcessing: boolean = false;

  async addJob(websiteId: number, type: 'ui' | 'scheduled'): Promise<void> {
    if (typeof websiteId !== 'number') {
      throw new Error('Invalid websiteId: must be a number');
    }
    this.queue.push({ websiteId, type });
    if (!this.isProcessing) {
      this.processNextJob();
    }
  }

  private async processNextJob(): Promise<void> {
    if (this.queue.length === 0) {
      this.isProcessing = false;
      return;
    }

    this.isProcessing = true;
    const job = this.queue.shift();

    if (job) {
      try {
        const { website } = await getWebsiteById(job.websiteId);
        if (website) {
          if (job.type === 'ui') {
            await processSingleWebsite(website);
          } else if (job.type === 'scheduled') {
            await processWebsiteForScheduledJob(website);
          }
        } else {
          console.error(`Website with id ${job.websiteId} not found`);
        }
      } catch (error) {
        console.error(`Error processing website ${job.websiteId}:`, error);
      }
    }

    setImmediate(() => this.processNextJob());
  }
}

const jobQueue = new JobQueue();

export default jobQueue;

// Filename: lib/scheduledSitemapProcessor.ts
import { Website, Page, IndexingStatus } from '@/types';
import { 
  getWebsitesForIndexing, 
  addOrUpdatePagesFromSitemap, 
  getPagesByWebsiteId,
  removePages,
  createIndexingJob,
  updateIndexingJob,
  createIndexingJobDetail,
  updateIndexingJobDetail
} from '@/models';
import { fetchBulkIndexingStatus, submitUrlForIndexing } from './googleSearchConsole';
import { getValidAccessToken } from '@/lib/tokenManager';
import { fetchUrl, extractSitemapUrls, parseSitemap } from './sitemapProcessor';

const indexed: string = 'Submitted and indexed';

export async function processWebsiteForScheduledJob(website: Website): Promise<void> {
  try {
    const job = await createIndexingJob({ website_id: website.id, status: 'in_progress', total_pages: 0 });
    const accessToken = await getValidAccessToken(website.user_id);

    const robotsTxtUrl = `https://${website.domain}/robots.txt`;
    const robotsTxtContent = await fetchUrl(robotsTxtUrl);
    const sitemapUrls = extractSitemapUrls(robotsTxtContent);

    let allPages: Page[] = [];
    for (const sitemapUrl of sitemapUrls) {
      const sitemapContent = await fetchUrl(sitemapUrl);
      const pages = await parseSitemap(sitemapContent);
      allPages = allPages.concat(pages);
    }

    const { pages: existingPages } = await getPagesByWebsiteId(website.id, true);
    const existingUrls = new Set(existingPages.map(page => page.url));
    const currentUrls = new Set(allPages.map(page => page.url));

    const newUrls = allPages.filter(page => !existingUrls.has(page.url));
    const removedUrls = existingPages.filter(page => !currentUrls.has(page.url));
    const unchangedUrls = allPages.filter(page => existingUrls.has(page.url));

    const urlsToCheck = [...newUrls, ...unchangedUrls].map(page => page.url);
    const indexingStatuses = await fetchBulkIndexingStatus(website.id, website.domain, accessToken, urlsToCheck);

    const pagesToUpdate = indexingStatuses.map(status => ({
      url: status.url,
      indexingStatus: status.indexingStatus,
      lastIndexedDate: status.lastIndexedDate
    }));

    await addOrUpdatePagesFromSitemap(website.id, pagesToUpdate);

    for (const page of pagesToUpdate) {
      if (page.indexingStatus !== indexed) {
        await submitUrlForIndexing(website.domain, page.url, accessToken);
        await createIndexingJobDetail({
          indexing_job_id: job.job.id,
          page_id: existingPages.find(p => p.url === page.url)?.id || 0,
          status: 'pending'
        });
      }
    }

    if (removedUrls.length > 0) {
      await removePages(website.id, removedUrls.map(page => page.id));
    }

    await updateIndexingJob(job.job.id, { 
      status: 'completed', 
      processed_pages: pagesToUpdate.length 
    });

  } catch (error) {
    console.error(`Error processing website ${website.domain}:`, error);
    throw error;
  }
}

// Filename: lib/sitemapProcessor.ts
import axios from 'axios';
import { parseString } from 'xml2js';
import { promisify } from 'util';
import jobQueue from '@/lib/jobQueue';
import { Website, IndexingStatus } from '@/types';
import { 
  getWebsitesForIndexing, 
  addOrUpdatePagesFromSitemap, 
  updateWebsiteRobotsScan, 
  getPagesByWebsiteId,
  removePages
} from '@/models';
import { fetchBulkIndexingStatus } from './googleSearchConsole';
import { getValidAccessToken } from './tokenManager';
import { ValidationError } from '@/utils/errors';

const parseXml = promisify(parseString);

function cleanDomain(inputDomain: string): string {
  let cleanedDomain = inputDomain.replace(/^sc-domain:/, '');
  try {
    const url = new URL(cleanedDomain);
    cleanedDomain = url.hostname;
  } catch {
    // If it's not a valid URL, assume it's already just a domain
  }
  cleanedDomain = cleanedDomain.replace(/^www\./, '');
  return cleanedDomain;
}

// Function to queue the website processing as background jobs
export async function scheduleSitemapProcessing(): Promise<void> {
  try {
    const websites = await getWebsitesForIndexing();
    for (const website of websites) {
      await jobQueue.addJob(website.id);
    }
  } catch (error) {
    console.error('Error in scheduled sitemap processing:', error);
  }
}

// Function to process a single website, called as part of the background job
export async function processSingleWebsite(website: Website): Promise<void> {
  try {
    const cleanedDomain = cleanDomain(website.domain);
    const robotsTxtUrl = `https://${cleanedDomain}/robots.txt`;
    const robotsTxtContent = await fetchUrl(robotsTxtUrl);
    const allSitemapUrls = extractSitemapUrls(robotsTxtContent);
    const filteredSitemapUrls = filterSitemaps(allSitemapUrls);

    let totalPages = 0;
    for (const sitemapUrl of filteredSitemapUrls) {
      const pageCount = await processSitemap(website.id, website.domain, sitemapUrl, website.user_id);
      totalPages += pageCount;
    }

    console.log(`Processed ${totalPages} pages for ${cleanedDomain}`);
    await updateWebsiteRobotsScan(website.id);
  } catch (error) {
    console.error(`Error processing website ${cleanDomain(website.domain)}:`, error);
  }
}

// Function to filter sitemaps based on their names
function filterSitemaps(sitemapUrls: string[]): string[] {
  const includePatterns = [
    /post-sitemap/,
    /page-sitemap/,
    /product-sitemap/,
    /^sitemap[-_]?index/,
    /^sitemap[-_]?pages/,
    /^sitemap[-_]?posts/,
    /^sitemap[-_]?products/
  ];

  const excludePatterns = [
    /category-sitemap/,
    /tag-sitemap/,
    /author-sitemap/,
    /^sitemap[-_]?category/,
    /^sitemap[-_]?tag/,
    /^sitemap[-_]?author/,
    /^sitemap[-_]?archive/
  ];

  return sitemapUrls.filter(url => {
    const sitemapName = new URL(url).pathname.split('/').pop() || '';
    
    if (excludePatterns.some(pattern => pattern.test(sitemapName))) {
      return false;
    }

    return includePatterns.some(pattern => pattern.test(sitemapName)) || sitemapName === 'sitemap.xml';
  });
}

async function processSitemap(websiteId: number, domain: string, sitemapUrl: string, userId: number): Promise<number> {
  try {
    const sitemapContent = await fetchUrl(sitemapUrl);
    const pages = await parseSitemap(sitemapContent);
    
    const urls = new Set(pages.map(page => page.url));

    // Fetch existing pages from the database
    const existingPages = await getPagesByWebsiteId(websiteId, true);

    // Identify pages to remove (in database but not in sitemap)
    const pagesToRemove = existingPages.pages.filter(page => !urls.has(page.url));

    // Fetch the actual indexing status and last indexed date from Google Search Console
    const accessToken = await getValidAccessToken(userId);
    const indexedPages = await fetchBulkIndexingStatus(websiteId, domain, accessToken, Array.from(urls));

    // Combine sitemap data with indexing data
    const formattedPages = pages.map(page => {
      const indexedPage = indexedPages.find(ip => ip.url === page.url);
      return {
        url: page.url,
        lastIndexedDate: indexedPage?.lastIndexedDate || null,
        indexingStatus: indexedPage?.indexingStatus || 'not_indexed' as IndexingStatus
      };
    });

    // Update or add pages
    await addOrUpdatePagesFromSitemap(websiteId, formattedPages);

    // Remove pages that are no longer in the sitemap
    if (pagesToRemove.length > 0) {
      await removePages(websiteId, pagesToRemove.map(page => page.id));
    }

    return pages.length;

  } catch (error) {
    console.error(`Error processing sitemap ${sitemapUrl}:`, error);
    return 0;
  }
}

// Function to parse the sitemap XML and extract URLs
export async function parseSitemap(sitemapContent: string): Promise<{ url: string }[]> {
  try {
    const result = await parseXml(sitemapContent);
    if (result.sitemapindex) {
      // Sitemap index file containing multiple sitemaps
      const sitemapUrls = result.sitemapindex.sitemap.map((sitemap: any) => sitemap.loc[0]);
      const filteredSitemapUrls = filterSitemaps(sitemapUrls);
      const allPages = await Promise.all(filteredSitemapUrls.map(fetchAndParseSitemap));
      return allPages.flat();
    } else if (result.urlset) {
      // Regular sitemap containing URLs
      return result.urlset.url.map((url: any) => ({ url: url.loc[0] }));
    } else {
      throw new ValidationError('Invalid sitemap format');
    }
  } catch (error) {
    console.error('Error parsing sitemap:', error);
    throw new ValidationError('Failed to parse sitemap');
  }
}

// Helper function to fetch and parse a sitemap from a given URL
export async function fetchAndParseSitemap(sitemapUrl: string): Promise<{ url: string }[]> {
  const sitemapContent = await fetchUrl(sitemapUrl);
  return parseSitemap(sitemapContent);
}

// Function to fetch URL content (robots.txt, sitemap.xml, etc.)
export async function fetchUrl(url: string): Promise<string> {
  try {
    const response = await axios.get(url);
    return response.data;
  } catch (error) {
    console.error(`Error fetching URL ${url}:`, error);
    throw new ValidationError(`Failed to fetch URL: ${url}`);
  }
}

// Function to extract sitemap URLs from robots.txt
export function extractSitemapUrls(robotsTxtContent: string): string[] {
  const lines = robotsTxtContent.split('\n');
  return lines
    .filter(line => line.toLowerCase().startsWith('sitemap:'))
    .map(line => line.split(': ')[1].trim());
}


// Filename: lib/theme.ts
// lib/theme.ts
import { createTheme, responsiveFontSizes } from '@mui/material/styles';
import { deepmerge } from '@mui/utils';

declare module '@mui/material/styles' {
  interface Palette {
    customBackground: Palette['primary'];
    customText: Palette['primary'];
  }
  interface PaletteOptions {
    customBackground?: PaletteOptions['primary'];
    customText?: PaletteOptions['primary'];
  }
}

// Create a base theme
const baseTheme = createTheme({
  palette: {
    primary: {
      main: '#0f766e',
      light: '#14b8a6',
      dark: '#0d5b54',
      contrastText: '#ffffff',
    },
    secondary: {
      main: '#0ea5e9',
      light: '#38bdf8',
      dark: '#0284c7',
      contrastText: '#ffffff',
    },
    error: {
      main: '#ef4444',
      light: '#f87171',
      dark: '#dc2626',
      contrastText: '#ffffff',
    },
    warning: {
      main: '#f59e0b',
      light: '#fbbf24',
      dark: '#d97706',
      contrastText: '#000000',
    },
    info: {
      main: '#3b82f6',
      light: '#60a5fa',
      dark: '#2563eb',
      contrastText: '#ffffff',
    },
    success: {
      main: '#10b981',
      light: '#34d399',
      dark: '#059669',
      contrastText: '#ffffff',
    },
    grey: {
      50: '#f9fafb',
      100: '#f3f4f6',
      200: '#e5e7eb',
      300: '#d1d5db',
      400: '#9ca3af',
      500: '#6b7280',
      600: '#4b5563',
      700: '#374151',
      800: '#1f2937',
      900: '#111827',
    },
    customBackground: {
      main: '#ffffff',
      light: '#f3f4f6',
      dark: '#e5e7eb',
    },
    customText: {
      main: '#111827',
      light: '#374151',
      dark: '#1f2937',
    },
    background: {
      default: '#f3f4f6',
      paper: '#ffffff',
    },
    text: {
      primary: '#111827',
      secondary: '#4b5563',
    },
  },
  typography: {
    fontFamily: '"Inter", "Roboto", "Helvetica", "Arial", sans-serif',
    h1: {
      fontSize: '2.5rem',
      fontWeight: 700,
      lineHeight: 1.2,
    },
    h2: {
      fontSize: '2rem',
      fontWeight: 700,
      lineHeight: 1.2,
    },
    h3: {
      fontSize: '1.75rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    h4: {
      fontSize: '1.5rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    h5: {
      fontSize: '1.25rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    h6: {
      fontSize: '1rem',
      fontWeight: 600,
      lineHeight: 1.2,
    },
    subtitle1: {
      fontSize: '1rem',
      fontWeight: 400,
      lineHeight: 1.5,
    },
    subtitle2: {
      fontSize: '0.875rem',
      fontWeight: 500,
      lineHeight: 1.57,
    },
    body1: {
      fontSize: '1rem',
      fontWeight: 400,
      lineHeight: 1.5,
    },
    body2: {
      fontSize: '0.875rem',
      fontWeight: 400,
      lineHeight: 1.43,
    },
    button: {
      fontSize: '0.875rem',
      fontWeight: 500,
      lineHeight: 1.75,
      textTransform: 'none',
    },
    caption: {
      fontSize: '0.75rem',
      fontWeight: 400,
      lineHeight: 1.66,
    },
    overline: {
      fontSize: '0.75rem',
      fontWeight: 600,
      lineHeight: 2.66,
      textTransform: 'uppercase',
    },
  },
  shape: {
    borderRadius: 8,
  },
  mixins: {
    toolbar: {
      minHeight: 64,
    },
  },
});

// Customize the base theme
const customTheme = deepmerge(baseTheme, {
  components: {
    MuiAppBar: {
      styleOverrides: {
        root: {
          backgroundColor: baseTheme.palette.background.paper,
          color: baseTheme.palette.text.primary,
          boxShadow: 'none',
          borderBottom: `1px solid ${baseTheme.palette.grey[200]}`,
        },
      },
    },
    MuiButton: {
      styleOverrides: {
        root: {
          textTransform: 'none',
          borderRadius: '0.375rem',
          fontWeight: 600,
          boxShadow: 'none',
          '&:hover': {
            boxShadow: 'none',
          },
        },
        containedPrimary: {
          '&:hover': {
            backgroundColor: baseTheme.palette.primary.dark,
          },
        },
        containedSecondary: {
          '&:hover': {
            backgroundColor: baseTheme.palette.secondary.dark,
          },
        },
      },
    },
    MuiCard: {
      styleOverrides: {
        root: {
          borderRadius: '0.5rem',
          boxShadow: '0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06)',
        },
      },
    },
    MuiCardHeader: {
      styleOverrides: {
        root: {
          padding: baseTheme.spacing(3),
        },
      },
    },
    MuiCardContent: {
      styleOverrides: {
        root: {
          padding: baseTheme.spacing(3),
        },
      },
    },
    MuiCardActions: {
      styleOverrides: {
        root: {
          padding: baseTheme.spacing(3),
        },
      },
    },
    MuiChip: {
      styleOverrides: {
        root: {
          borderRadius: '0.375rem',
        },
      },
    },
    MuiDialog: {
      styleOverrides: {
        paper: {
          borderRadius: '0.5rem',
        },
      },
    },
    MuiDivider: {
      styleOverrides: {
        root: {
          borderColor: baseTheme.palette.grey[200],
        },
      },
    },
    MuiInputBase: {
      styleOverrides: {
        root: {
          borderRadius: '0.375rem',
        },
      },
    },
    MuiOutlinedInput: {
      styleOverrides: {
        root: {
          '& .MuiOutlinedInput-notchedOutline': {
            borderColor: baseTheme.palette.grey[300],
          },
          '&:hover .MuiOutlinedInput-notchedOutline': {
            borderColor: baseTheme.palette.grey[400],
          },
          '&.Mui-focused .MuiOutlinedInput-notchedOutline': {
            borderColor: baseTheme.palette.primary.main,
          },
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          backgroundImage: 'none',
        },
      },
    },
    MuiTableCell: {
      styleOverrides: {
        root: {
          borderBottom: `1px solid ${baseTheme.palette.grey[200]}`,
        },
      },
    },
    MuiTableHead: {
      styleOverrides: {
        root: {
          backgroundColor: baseTheme.palette.grey[50],
          '.MuiTableCell-root': {
            color: baseTheme.palette.text.secondary,
            fontWeight: 600,
          },
        },
      },
    },
    MuiTooltip: {
      styleOverrides: {
        tooltip: {
          backgroundColor: baseTheme.palette.grey[800],
        },
      },
    },
  },
});

// Make the theme responsive
const theme = responsiveFontSizes(customTheme);

export default theme;

// Filename: lib/tokenManager.ts
// File: lib/tokenManager.ts

import { OAuth2Client } from 'google-auth-library';
import { getUserTokens, updateUserTokens } from '@/models';
import { UserTokens } from '@/types/index';
import { TokenError, DatabaseError, AuthorizationError } from '@/utils/errors';
import CONFIG from '@/config';

const oauth2Client = new OAuth2Client(
  CONFIG.google.clientId,
  CONFIG.google.clientSecret
);

const TOKEN_EXPIRY_BUFFER = 5 * 60 * 1000; // 5 minutes in milliseconds

export async function getValidAccessToken(userId: number): Promise<string> {
  try {
    const tokens = await getUserTokens(userId);
    if (!tokens) {
      throw new TokenError('User tokens not found');
    }

    const { accessToken, refreshToken, expiresAt } = tokens;

    if (!expiresAt) {
      throw new TokenError('Token expiration time not set');
    }

    const expiryTime = new Date(expiresAt).getTime();
    const currentTime = Date.now();

    if (expiryTime - currentTime < TOKEN_EXPIRY_BUFFER) {
      // Token is expired or close to expiring, refresh it
      try {
        console.log('Refreshing access token...');
        const newTokens = await refreshAccessToken(refreshToken);
        await updateUserTokens(userId, newTokens.access_token, newTokens.refresh_token, newTokens.expires_at);
        console.log('Access token refreshed successfully');
        return newTokens.access_token;
      } catch (refreshError) {
        console.error('Error refreshing access token:', refreshError);
        if (refreshError instanceof AuthorizationError) {
          // Handle re-authentication need
          throw new AuthorizationError('User needs to re-authenticate');
        }
        throw refreshError;
      }
    }

    return accessToken;
  } catch (error) {
    console.error('Error in getValidAccessToken:', error);
    if (error instanceof TokenError || error instanceof AuthorizationError) {
      throw error;
    } else {
      throw new TokenError(`An unexpected error occurred while getting access token: ${error.message}`);
    }
  }
}

export async function refreshAccessToken(refreshToken: string): Promise<UserTokens> {
  try {
    oauth2Client.setCredentials({ refresh_token: refreshToken });

    const { tokens } = await oauth2Client.refreshAccessToken();
    
    if (!tokens || !tokens.access_token) {
      throw new TokenError('Failed to refresh access token: No tokens received');
    }

    const accessToken = tokens.access_token;
    const newRefreshToken = tokens.refresh_token || refreshToken; // Use the new refresh token if provided, otherwise keep the old one
    const expiresAt = tokens.expiry_date 
      ? new Date(tokens.expiry_date).toISOString()
      : new Date(Date.now() + 3600 * 1000).toISOString(); // Default to 1 hour from now if expiry_date is not provided

    return {
      access_token: accessToken,
      refresh_token: newRefreshToken,
      expires_at: expiresAt,
    };
  } catch (error: any) {
    console.error('Error refreshing access token:', error);
    if (error.response && error.response.status === 400) {
      throw new AuthorizationError('Invalid refresh token. User may need to re-authenticate.');
    } else if (error.response && error.response.status === 401) {
      throw new AuthorizationError('Refresh token has been revoked or expired. User needs to re-authenticate.');
    } else {
      throw new TokenError(`Failed to refresh access token: ${error.message}`);
    }
  }
}

export async function updateTokenExpiration(userId: number, expiresIn: number): Promise<void> {
  try {
    const expiresAt = new Date(Date.now() + expiresIn * 1000).toISOString();
    await updateUserTokens(userId, null, null, expiresAt);
  } catch (error) {
    console.error('Error updating token expiration:', error);
    if (error instanceof DatabaseError) {
      throw new TokenError('Failed to update token expiration in database');
    } else {
      throw new TokenError('An unexpected error occurred while updating token expiration');
    }
  }
}

export async function revokeToken(userId: number): Promise<void> {
  try {
    const tokens = await getUserTokens(userId);
    if (!tokens || !tokens.accessToken) {
      throw new TokenError('No valid token found for user');
    }

    await oauth2Client.revokeToken(tokens.accessToken);
    await updateUserTokens(userId, null, null, null); // Clear tokens in database
  } catch (error) {
    console.error('Error revoking token:', error);
    if (error instanceof TokenError) {
      throw error;
    } else if (error instanceof DatabaseError) {
      throw new TokenError('Failed to update token information after revocation');
    } else {
      throw new TokenError('An unexpected error occurred while revoking token');
    }
  }
}

// Filename: lib/useError.ts
// lib/useError.ts
import { useContext } from 'react';
import { ErrorContext } from './ErrorContext';

export function useError() {
  const { setError } = useContext(ErrorContext);
  return setError;
}

// Filename: middleware/authMiddleware.ts
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';
import { getToken } from 'next-auth/jwt';
import { getValidAccessToken } from '@/lib/tokenManager';

export async function middleware(request: NextRequest) {
  const token = await getToken({ req: request, secret: process.env.NEXTAUTH_SECRET });

  if (!token && !request.nextUrl.pathname.startsWith('/auth')) {
    return NextResponse.redirect(new URL('/auth/signin', request.url));
  }

  try {
    // The token should contain userId and potentially an access token
    const userId = token.userId as number;

    // Retrieve or refresh the Google OAuth access token
    const validAccessToken = await getValidAccessToken(userId);

    // Add the valid access token to the request headers
    const requestHeaders = new Headers(request.headers);
    requestHeaders.set('X-Access-Token', validAccessToken); // Adding Google OAuth token for API requests

    // Create a new request with the updated headers
    const response = NextResponse.next({
      request: {
        headers: requestHeaders,
      },
    });

    return response;
  } catch (error) {
    console.error('Error in token middleware:', error);

    // Token-related errors should redirect the user to the sign-in page
    const url = request.nextUrl.clone();
    url.pathname = '/auth/signin';
    return NextResponse.redirect(url);
  }
}

// Only match requests that are not static files, API calls, or auth-related routes
export const config = {
  matcher: [
    '/((?!api|_next/static|_next/image|favicon.ico|auth).*)',
  ],
};


// Filename: middleware/errorHandler.ts
// File: middleware/errorHandler.ts

import { NextApiRequest, NextApiResponse } from 'next';
import { AppError, createErrorResponse, getClientErrorMessage, DatabaseError, ValidationError, AuthenticationError, AuthorizationError, NotFoundError } from '@/utils/errors';

export const errorHandler = (handler: (req: NextApiRequest, res: NextApiResponse) => Promise<void>) => {
  return async (req: NextApiRequest, res: NextApiResponse): Promise<void> => {
    try {
      await handler(req, res);
    } catch (error: any) {
      console.error('Error:', error);

      let appError: AppError;

      if (error instanceof AppError) {
        appError = error;
      } else if (error instanceof Error) {
        // Convert generic errors to AppError
        appError = new AppError(error.message, 500, 'INTERNAL_SERVER_ERROR');
      } else {
        appError = new AppError('An unexpected error occurred', 500, 'INTERNAL_SERVER_ERROR');
      }

      const errorResponse = createErrorResponse(appError);
      const clientMessage = getClientErrorMessage(appError);

      // In production, we might want to hide the actual error message and only show the client-friendly message
      if (process.env.NODE_ENV === 'production') {
        errorResponse.message = clientMessage;
      } else {
        // In development, we can show both the original error and the client-friendly message
        errorResponse.message = `${errorResponse.message} (Client message: ${clientMessage})`;
      }

      res.status(appError.statusCode).json(errorResponse);
    }
  };
};

export const withErrorHandling = <T>(handler: () => Promise<T>): Promise<T> => {
  return handler().catch((error) => {
    if (error instanceof AppError) {
      throw error;
    }
    if (error instanceof Error) {
      // Convert known error types to specific AppError subclasses
      if (error.name === 'DatabaseError') {
        throw new DatabaseError(error.message);
      }
      if (error.name === 'ValidationError') {
        throw new ValidationError(error.message);
      }
      if (error.name === 'AuthenticationError') {
        throw new AuthenticationError(error.message);
      }
      if (error.name === 'AuthorizationError') {
        throw new AuthorizationError(error.message);
      }
      if (error.name === 'NotFoundError') {
        throw new NotFoundError(error.message);
      }
    }
    // For unknown errors, throw a generic AppError
    throw new AppError('An unexpected error occurred', 500, 'INTERNAL_SERVER_ERROR');
  });
};

// Filename: models/index.ts
// File: models/index.ts

import pool from '@/lib/db';
import { User, Website, Page, IndexingJob, IndexingJobDetail, IndexingStatus, IndexingStatsData, EmailNotification } from '@/types';
import { DatabaseError } from '@/utils/errors';

// Helper function to handle database errors
function handleDatabaseError(error: any): never {
  console.error('Database error:', error);
  if (error.code === '23505') { // unique_violation
    throw new DatabaseError('Duplicate entry');
  } else if (error.code === '23503') { // foreign_key_violation
    throw new DatabaseError('Related resource not found');
  } else {
    throw new DatabaseError('Database error occurred');
  }
}

export async function getUserByEmail(email: string): Promise<{ user: User | null, statusCode: number }> {
  try {
    const query = 'SELECT * FROM users WHERE email = $1';
    const result = await pool.query(query, [email]);
    return { user: result.rows[0] || null, statusCode: result.rows[0] ? 200 : 404 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createUser(user: Partial<User>): Promise<{ user: User, statusCode: number }> {
  try {
    const { name, email, google_id, access_token, refresh_token, expires_at } = user;
    const query = 'INSERT INTO users (name, email, google_id, access_token, refresh_token, expires_at) VALUES ($1, $2, $3, $4, $5, $6) RETURNING *';
    const result = await pool.query(query, [name, email, google_id, access_token, refresh_token, expires_at]);
    return { user: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updateUser(id: number, user: Partial<User>): Promise<{ user: User, statusCode: number }> {
  try {
    const { name, google_id, access_token, refresh_token, expires_at } = user;
    const query = 'UPDATE users SET name = COALESCE($1, name), google_id = COALESCE($2, google_id), access_token = COALESCE($3, access_token), refresh_token = COALESCE($4, refresh_token), expires_at = COALESCE($5, expires_at), updated_at = CURRENT_TIMESTAMP WHERE id = $6 RETURNING *';
    const result = await pool.query(query, [name, google_id, access_token, refresh_token, expires_at, id]);
    if (result.rowCount === 0) {
      throw new DatabaseError('User not found');
    }
    return { user: result.rows[0], statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updateUserTokens(userId: number, accessToken: string | null, refreshToken: string | null, expiresAt: string | null): Promise<void> {
  try {
    const query = `
      UPDATE users
      SET access_token = COALESCE($1, access_token),
          refresh_token = COALESCE($2, refresh_token),
          expires_at = COALESCE($3, expires_at),
          updated_at = CURRENT_TIMESTAMP
      WHERE id = $4
    `;
    await pool.query(query, [accessToken, refreshToken, expiresAt, userId]);
  } catch (error) {
    console.error('Error updating user tokens:', error);
    throw error;
  }
}

export async function getUserTokens(userId: number): Promise<{ accessToken: string, refreshToken: string, expiresAt: string } | null> {
  try {
    const query = 'SELECT access_token, refresh_token, expires_at FROM users WHERE id = $1';
    const result = await pool.query(query, [userId]);
    if (result.rows.length > 0) {
      return {
        accessToken: result.rows[0].access_token,
        refreshToken: result.rows[0].refresh_token,
        expiresAt: result.rows[0].expires_at
      };
    }
    return null;
  } catch (error) {
    console.error('Error getting user tokens:', error);
    throw error;
  }
}

export async function getWebsitesByUserId(userId: number): Promise<{ websites: Website[], statusCode: number }> {
  try {
    const query = 'SELECT * FROM websites WHERE user_id = $1';
    const result = await pool.query(query, [userId]);
    return { websites: result.rows, statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function getWebsiteById(id: number): Promise<{ website: Website | null, statusCode: number }> {
  try {
    const query = 'SELECT * FROM websites WHERE id = $1';
    const result = await pool.query(query, [id]);
    return { website: result.rows[0] || null, statusCode: result.rows[0] ? 200 : 404 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function getIndexingStatsByWebsiteId(id: number): Promise<{ indexingStats: IndexingStatsData | null, statusCode: number}> {
  try {
    const query = 'SELECT * FROM get_indexing_stats($1)';
    const result = await pool.query(query, [id]);
    return { indexingStats: result.rows[0] || null, statusCode: result.rows[0] ? 200 : 404 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function getWebsitesForIndexing(): Promise<{ websites: Website[], statusCode: number }> {
  try {
    const query = `
      SELECT * FROM websites 
      WHERE indexing_enabled = true 
      AND (last_robots_scan IS NULL OR last_robots_scan < NOW() - INTERVAL '1 day')
    `;
    const result = await pool.query(query);
    return { websites: result.rows, statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createWebsite(website: Partial<Website>): Promise<{ website: Website, statusCode: number }> {
  try {
    const { user_id, domain, indexing_enabled, ga4_property_id, ga4_data_stream_id } = website;
    const query = 'INSERT INTO websites (user_id, domain, indexing_enabled, ga4_property_id, ga4_data_stream_id) VALUES ($1, $2, $3, $4, $5) RETURNING *';
    const result = await pool.query(query, [user_id, domain, indexing_enabled, ga4_property_id, ga4_data_stream_id]);
    return { website: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updateWebsite(id: number, website: Partial<Website>): Promise<{ website: Website, statusCode: number }> {
  try {
    const { domain, indexing_enabled, ga4_property_id, ga4_data_stream_id } = website;
    const query = `
      UPDATE websites 
      SET domain = COALESCE($1, domain), 
          indexing_enabled = COALESCE($2, indexing_enabled),
          ga4_property_id = COALESCE($3, ga4_property_id),
          ga4_data_stream_id = COALESCE($4, ga4_data_stream_id),
          updated_at = CURRENT_TIMESTAMP 
      WHERE id = $5 
      RETURNING *
    `;
    const result = await pool.query(query, [domain, indexing_enabled, ga4_property_id, ga4_data_stream_id, id]);
    if (result.rowCount === 0) {
      throw new DatabaseError('Website not found');
    }
    return { website: result.rows[0], statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updateWebsiteRobotsScan(id: number): Promise<{ statusCode: number }> {
  try {
    const query = 'SELECT update_website_robots_scan($1)';
    await pool.query(query, [id]);
    return { statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function getPagesByWebsiteId(
  websiteId: number, 
  all: boolean = false,
  page: number = 0, 
  pageSize: number = 25, 
  orderBy: string = 'url', 
  order: 'asc' | 'desc' = 'asc'
): Promise<{ pages: Page[], totalCount: number, statusCode: number }> {
  try {
    let query: string;
    let countQuery: string;
    let queryParams: any[];

    if (all) {
      query = 'SELECT * FROM pages WHERE website_id = $1';
      countQuery = 'SELECT COUNT(*) FROM pages WHERE website_id = $1';
      queryParams = [websiteId];
    } else {
      const offset = page * pageSize;
      query = `
        SELECT * FROM pages 
        WHERE website_id = $1 
        ORDER BY ${orderBy} ${order}
        LIMIT $2 OFFSET $3
      `;
      countQuery = 'SELECT COUNT(*) FROM pages WHERE website_id = $1';
      queryParams = [websiteId, pageSize, offset];
    }
    
    const [result, countResult] = await Promise.all([
      pool.query(query, queryParams),
      pool.query(countQuery, [websiteId])
    ]);

    return { 
      pages: result.rows, 
      totalCount: parseInt(countResult.rows[0].count), 
      statusCode: 200 
    };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function getPageById(id: number): Promise<{ page: Page | null, statusCode: number }> {
  try {
    const query = 'SELECT * FROM pages WHERE id = $1';
    const result = await pool.query(query, [id]);
    return { page: result.rows[0] || null, statusCode: result.rows[0] ? 200 : 404 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createPage(page: Partial<Page>): Promise<{ page: Page, statusCode: number }> {
  try {
    const { website_id, url } = page;
    const query = 'INSERT INTO pages (website_id, url) VALUES ($1, $2) RETURNING *';
    const result = await pool.query(query, [website_id, url]);
    return { page: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updatePageData(websiteId: number, url: string, indexingStatus: string, lastIndexed: Date | null): Promise<void> {
  try {
    const query = `
      UPDATE pages
      SET indexing_status = $1,
          last_indexed_date = $2,
          updated_at = CURRENT_TIMESTAMP
      WHERE website_id = $3 AND url = $4
    `;
    await pool.query(query, [indexingStatus, lastIndexed, websiteId, url]);
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function addOrUpdatePagesFromSitemap(websiteId: number, pages: { url: string, lastIndexedDate?: string | null, indexingStatus?: IndexingStatus }[]
): Promise<{ statusCode: number }> {
  try {
    const query = 'SELECT bulk_upsert_pages($1, $2)';
    await pool.query(query, [websiteId, JSON.stringify(pages)]);
    return { statusCode: 200 };

  } catch (error) {
    console.error('Error in addOrUpdatePagesFromSitemap:', error);
    throw error;
  }
}

export async function removePages(websiteId: number, pageIds: number[]): Promise<{ statusCode: number }> {
  try {
    const query = `
      DELETE FROM pages
      WHERE website_id = $1 AND id = ANY($2::int[])
    `;
    await pool.query(query, [websiteId, pageIds]);
    return { statusCode: 200 };
  } catch (error) {
    console.error('Error removing pages:', error);
    handleDatabaseError(error);
  }
}

export async function getPagesForIndexing(websiteId: number, limit: number): Promise<{ pages: Page[], statusCode: number }> {
  try {
    const query = 'SELECT * FROM get_pages_for_indexing($1, $2)';
    const result = await pool.query(query, [websiteId, limit]);
    return { pages: result.rows, statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createIndexingJob(job: Partial<IndexingJob>): Promise<{ job: IndexingJob, statusCode: number }> {
  try {
    const { website_id, status, total_pages } = job;
    const query = 'INSERT INTO indexing_jobs (website_id, status, started_at, total_pages, processed_pages) VALUES ($1, $2, CURRENT_TIMESTAMP, $3, 0) RETURNING *';
    const result = await pool.query(query, [website_id, status, total_pages]);
    return { job: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updateIndexingJob(id: number, job: Partial<IndexingJob>): Promise<{ job: IndexingJob, statusCode: number }> {
  try {
    const { status, processed_pages } = job;
    const query = 'UPDATE indexing_jobs SET status = COALESCE($1, status), processed_pages = COALESCE($2, processed_pages), completed_at = CASE WHEN $1 = \'completed\' THEN CURRENT_TIMESTAMP ELSE completed_at END, updated_at = CURRENT_TIMESTAMP WHERE id = $3 RETURNING *';
    const result = await pool.query(query, [status, processed_pages, id]);
    if (result.rowCount === 0) {
      throw new DatabaseError('Indexing job not found');
    }
    return { job: result.rows[0], statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createIndexingJobDetail(detail: Partial<IndexingJobDetail>): Promise<{ detail: IndexingJobDetail, statusCode: number }> {
  try {
    const { indexing_job_id, page_id, status } = detail;
    const query = 'INSERT INTO indexing_job_details (indexing_job_id, page_id, status, submitted_at) VALUES ($1, $2, $3, CURRENT_TIMESTAMP) RETURNING *';
    const result = await pool.query(query, [indexing_job_id, page_id, status]);
    return { detail: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function updateIndexingJobDetail(id: number, detail: Partial<IndexingJobDetail>): Promise<{ detail: IndexingJobDetail, statusCode: number }> {
  try {
    const { status, response } = detail;
    const query = 'SELECT * FROM update_indexing_job_detail_status($1, $2, $3)';
    const result = await pool.query(query, [id, status, response]);
    if (result.rowCount === 0) {
      throw new DatabaseError('Indexing job detail not found');
    }
    return { detail: result.rows[0], statusCode: 200 };
  } catch (error) {
    handleDatabaseError(error);
  }
}

export async function createEmailNotification(notification: Partial<EmailNotification>): Promise<{ notification: EmailNotification, statusCode: number }> {
  try {
    const { user_id, website_id, type, content } = notification;
    const query = 'SELECT * FROM create_email_notification($1, $2, $3, $4)';
    const result = await pool.query(query, [user_id, website_id, type, content]);
    return { notification: result.rows[0], statusCode: 201 };
  } catch (error) {
    handleDatabaseError(error);
  }
}


// Filename: next-env.d.ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/building-your-application/configuring/typescript for more information.


// Filename: next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: '/api/:path*',
      },
    ]
  },
}

module.exports = nextConfig

// Filename: types/index.ts
// File: types/index.ts

export interface UserTokens {
  access_token: string | null;
  refresh_token: string | null;
  expires_at: string | null;
}

export interface User {
  id: number;
  email: string;
  name: string | null;
  google_id: string | null;
  access_token: string | null;
  refresh_token: string | null;
  expires_at: Date | null;
  created_at: Date;
  updated_at: Date;
}
  
export interface Website {
  id: number;
  user_id: number;
  domain: string;
  last_robots_scan: Date | null;
  indexing_enabled: boolean;
  ga4_property_id: string | null;
  ga4_data_stream_id: string | null;
  created_at: Date;
  updated_at: Date;
}

export interface Page {
  id: number;
  website_id: number;
  url: string;
  last_sitemap_check: Date | null;
  last_indexed_date: Date | null;
  indexing_status: IndexingStatus;
  created_at: Date;
  updated_at: Date;
}
  
export type IndexingStatus = 'not_indexed' | 'pending' | 'indexed' | 'failed';

export interface IndexingJob {
  id: number;
  website_id: number;
  status: JobStatus;
  started_at: Date | null;
  completed_at: Date | null;
  total_pages: number;
  processed_pages: number;
  created_at: Date;
  updated_at: Date;
}

export type JobStatus = 'pending' | 'in_progress' | 'completed' | 'failed';

export interface IndexingJobDetail {
  id: number;
  indexing_job_id: number;
  page_id: number;
  status: IndexingStatus;
  submitted_at: Date | null;
  response: string | null;
  created_at: Date;
  updated_at: Date;
}

export interface EmailNotification {
  id: number;
  user_id: number;
  website_id: number;
  type: NotificationType;
  content: string;
  sent_at: Date | null;
  created_at: Date;
}

export type NotificationType = 'indexing_complete' | 'indexing_failed' | 'new_page_found';

export interface IndexingStatsData {
  total_pages: number;
  indexed_pages: number;
  not_indexed_pages: number;
}

// Filename: types/next-auth.d.ts
import NextAuth from "next-auth"

declare module "next-auth" {
  interface Session {
    user: {
      id: string
      name?: string | null
      email?: string | null
      image?: string | null
    }
  }
}

// Filename: utils/apiUtils.ts
// File: utils/apiUtils.ts
import { NextResponse } from 'next/server';
import { AppError, DatabaseError, ValidationError, AuthenticationError, AuthorizationError, NotFoundError } from './errors';

export async function handleApiError(error: unknown): Promise<NextResponse> {
  console.error('API Error:', error);

  let appError: AppError;

  if (error instanceof AppError) {
    appError = error;
  } else if (error instanceof Error) {
    // Convert known error types to specific AppError subclasses
    if (error.name === 'DatabaseError') {
      appError = new DatabaseError(error.message);
    } else if (error.name === 'ValidationError') {
      appError = new ValidationError(error.message);
    } else if (error.name === 'AuthenticationError') {
      appError = new AuthenticationError(error.message);
    } else if (error.name === 'AuthorizationError') {
      appError = new AuthorizationError(error.message);
    } else if (error.name === 'NotFoundError') {
      appError = new NotFoundError(error.message);
    } else {
      appError = new AppError(error.message, 500, 'INTERNAL_SERVER_ERROR');
    }
  } else {
    appError = new AppError('An unexpected error occurred', 500, 'INTERNAL_SERVER_ERROR');
  }

  const errorResponse = {
    status: 'error',
    message: appError.message,
    errorCode: appError.errorCode,
  };

  return NextResponse.json(errorResponse, { status: appError.statusCode });
}

export function withErrorHandling(handler: (req: NextRequest) => Promise<NextResponse>) {
  return async (req: NextRequest) => {
    try {
      return await handler(req);
    } catch (error) {
      return handleApiError(error);
    }
  };
}

// Filename: utils/errors.ts
// File: utils/errors.ts

export interface ErrorResponse {
  status: 'error';
  message: string;
  statusCode: number;
  errorCode?: string;
}

export class AppError extends Error {
  statusCode: number;
  errorCode: string;

  constructor(message: string, statusCode: number, errorCode: string) {
    super(message);
    this.name = this.constructor.name;
    this.statusCode = statusCode;
    this.errorCode = errorCode;
    Error.captureStackTrace(this, this.constructor);
  }
}

export class DatabaseError extends AppError {
  constructor(message = 'A database error occurred') {
    super(message, 500, 'DATABASE_ERROR');
  }
}

export class ValidationError extends AppError {
  constructor(message = 'Invalid input data') {
    super(message, 400, 'VALIDATION_ERROR');
  }
}

export class AuthenticationError extends AppError {
  constructor(message = 'Authentication failed') {
    super(message, 401, 'AUTHENTICATION_ERROR');
  }
}

export class AuthorizationError extends AppError {
  constructor(message = 'You do not have permission to perform this action') {
    super(message, 403, 'AUTHORIZATION_ERROR');
  }
}

export class NotFoundError extends AppError {
  constructor(message = 'The requested resource was not found') {
    super(message, 404, 'NOT_FOUND_ERROR');
  }
}

export class TokenError extends AppError {
  constructor(message = 'Token error occurred') {
    super(message, 401, 'TOKEN_ERROR');
  }
}

export class AccessRevokedError extends AppError {
  constructor(message = 'Access has been revoked') {
    super(message, 403, 'ACCESS_REVOKED_ERROR');
  }
}

export function createErrorResponse(error: AppError): ErrorResponse {
  return {
    status: 'error',
    message: error.message,
    statusCode: error.statusCode,
    errorCode: error.errorCode
  };
}

export function getClientErrorMessage(error: AppError): string {
  switch (error.errorCode) {
    case 'DATABASE_ERROR':
      return 'We\'re experiencing technical difficulties. Please try again later.';
    case 'VALIDATION_ERROR':
      return 'Please check your input and try again.';
    case 'AUTHENTICATION_ERROR':
      return 'Please log in to continue.';
    case 'AUTHORIZATION_ERROR':
      return 'You don\'t have permission to perform this action.';
    case 'NOT_FOUND_ERROR':
      return 'The requested information could not be found.';
    case 'TOKEN_ERROR':
      return 'There was an issue with your authentication. Please try logging in again.';
    case 'ACCESS_REVOKED_ERROR':
      return 'Your access to the required services has been revoked. Please re-authorize the application.';
    default:
      return 'An unexpected error occurred. Please try again later.';
  }
}

// Filename: utils/runMigrations.ts
import fs from 'fs';
import path from 'path';
import pool from '@/lib/db';

export async function runMigrations() {
  const migrationsDir = path.join(process.cwd(), 'migrations');
  const migrationFiles = fs.readdirSync(migrationsDir).sort();

  for (const file of migrationFiles) {
    const migration = fs.readFileSync(path.join(migrationsDir, file), 'utf-8');
    try {
      await pool.query(migration);
      console.log(`Ran migration: ${file}`);
    } catch (error) {
      console.error(`Error running migration ${file}:`, error);
      throw error;
    }
  }
}
